#!/usr/bin/env python3
"""
SerialCom - Graphical interface for serial communication via picocom
Version: 1.1
"""

import sys
import os
import subprocess
import glob
import json
import socket
import threading
import socketserver
from pathlib import Path
import pyte
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QComboBox, QPushButton, QGroupBox, QFormLayout, QMessageBox,
    QTextEdit, QPlainTextEdit, QDialog, QInputDialog, QLineEdit,
    QGraphicsDropShadowEffect, QCheckBox, QFileDialog
)
from PyQt6.QtCore import Qt, QProcess, pyqtSignal, QTimer
from PyQt6.QtGui import QFont, QTextCursor, QKeyEvent, QTextBlockFormat, QColor

# Application version
VERSION = "1.1"

try:
    from PyQt6.QtSerialPort import QSerialPortInfo
    SERIAL_PORT_AVAILABLE = True
except ImportError:
    SERIAL_PORT_AVAILABLE = False


class TFTPHandler(socketserver.BaseRequestHandler):
    """Simple TFTP request handler supporting RRQ (read) operations"""

    TFTP_OPCODES = {
        1: 'RRQ',   # Read request
        2: 'WRQ',   # Write request
        3: 'DATA',  # Data
        4: 'ACK',   # Acknowledgment
        5: 'ERROR'  # Error
    }

    def handle(self):
        data, sock = self.request
        opcode = int.from_bytes(data[0:2], 'big')

        if opcode == 1:  # RRQ - Read Request
            self.handle_rrq(data, sock)
        elif opcode == 2:  # WRQ - Write Request
            self.handle_wrq(data, sock)

    def handle_rrq(self, data, sock):
        """Handle read request - send file to client"""
        # Parse filename from request
        parts = data[2:].split(b'\x00')
        filename = parts[0].decode('utf-8')

        # Get the file path from server's root directory
        filepath = os.path.join(self.server.tftp_root, filename)

        if not os.path.exists(filepath):
            # Send error: File not found
            error_packet = b'\x00\x05\x00\x01File not found\x00'
            sock.sendto(error_packet, self.client_address)
            print(f"[TFTP] File not found: {filename}")
            return

        try:
            with open(filepath, 'rb') as f:
                block_num = 1
                while True:
                    file_data = f.read(512)
                    # Build DATA packet: opcode (2 bytes) + block# (2 bytes) + data
                    data_packet = b'\x00\x03' + block_num.to_bytes(2, 'big') + file_data
                    sock.sendto(data_packet, self.client_address)

                    # Wait for ACK
                    sock.settimeout(5.0)
                    try:
                        ack_data, _ = sock.recvfrom(516)
                        ack_opcode = int.from_bytes(ack_data[0:2], 'big')
                        ack_block = int.from_bytes(ack_data[2:4], 'big')

                        if ack_opcode != 4 or ack_block != block_num:
                            print(f"[TFTP] Unexpected ACK: opcode={ack_opcode}, block={ack_block}")
                            break
                    except socket.timeout:
                        print(f"[TFTP] Timeout waiting for ACK block {block_num}")
                        break

                    if len(file_data) < 512:
                        # Last block sent
                        print(f"[TFTP] Transfer complete: {filename}")
                        break

                    block_num += 1

        except Exception as e:
            error_packet = b'\x00\x05\x00\x00' + str(e).encode() + b'\x00'
            sock.sendto(error_packet, self.client_address)
            print(f"[TFTP] Error reading file: {e}")

    def handle_wrq(self, data, sock):
        """Handle write request - receive file from client"""
        # Parse filename from request
        parts = data[2:].split(b'\x00')
        filename = parts[0].decode('utf-8')

        # Get the file path in server's root directory
        filepath = os.path.join(self.server.tftp_root, filename)

        try:
            # Send ACK for block 0 to start transfer
            ack_packet = b'\x00\x04\x00\x00'
            sock.sendto(ack_packet, self.client_address)

            with open(filepath, 'wb') as f:
                block_num = 1
                while True:
                    sock.settimeout(5.0)
                    try:
                        data_packet, _ = sock.recvfrom(516)
                        opcode = int.from_bytes(data_packet[0:2], 'big')
                        recv_block = int.from_bytes(data_packet[2:4], 'big')

                        if opcode != 3 or recv_block != block_num:
                            print(f"[TFTP] Unexpected DATA: opcode={opcode}, block={recv_block}")
                            break

                        file_data = data_packet[4:]
                        f.write(file_data)

                        # Send ACK
                        ack_packet = b'\x00\x04' + block_num.to_bytes(2, 'big')
                        sock.sendto(ack_packet, self.client_address)

                        if len(file_data) < 512:
                            print(f"[TFTP] Receive complete: {filename}")
                            break

                        block_num += 1

                    except socket.timeout:
                        print(f"[TFTP] Timeout waiting for DATA block {block_num}")
                        break

        except Exception as e:
            error_packet = b'\x00\x05\x00\x00' + str(e).encode() + b'\x00'
            sock.sendto(error_packet, self.client_address)
            print(f"[TFTP] Error writing file: {e}")


class TFTPServer:
    """Simple TFTP Server"""

    def __init__(self, host='0.0.0.0', port=69, root_dir=None):
        self.host = host
        self.port = port
        self.root_dir = root_dir or os.path.expanduser('~')
        self.server = None
        self.thread = None
        self.running = False

    def start(self):
        """Start the TFTP server in a background thread"""
        if self.running:
            return False

        try:
            self.server = socketserver.UDPServer((self.host, self.port), TFTPHandler)
            self.server.tftp_root = self.root_dir
            self.thread = threading.Thread(target=self._serve, daemon=True)
            self.thread.start()
            self.running = True
            print(f"[TFTP] Server started on {self.host}:{self.port}, root: {self.root_dir}")
            return True
        except PermissionError:
            print(f"[TFTP] Permission denied for port {self.port}. Try running with sudo or use port > 1024")
            return False
        except Exception as e:
            print(f"[TFTP] Failed to start server: {e}")
            return False

    def _serve(self):
        """Serve requests until stopped"""
        while self.running:
            self.server.handle_request()

    def stop(self):
        """Stop the TFTP server"""
        if not self.running:
            return

        self.running = False
        if self.server:
            self.server.shutdown()
            self.server = None
        print("[TFTP] Server stopped")

    def is_running(self):
        return self.running


def get_network_interfaces():
    """Get list of network interfaces with their IP addresses"""
    interfaces = []

    try:
        # Use ip command to get interface information
        result = subprocess.run(['ip', '-4', 'addr', 'show'], capture_output=True, text=True)

        current_iface = None
        for line in result.stdout.split('\n'):
            # Match interface line (e.g., "2: eth0: <BROADCAST...")
            if ': ' in line and not line.startswith(' '):
                parts = line.split(': ')
                if len(parts) >= 2:
                    current_iface = parts[1].split('@')[0]

            # Match inet line (e.g., "    inet 192.168.1.100/24...")
            elif 'inet ' in line and current_iface:
                parts = line.strip().split()
                if len(parts) >= 2:
                    ip_with_mask = parts[1]
                    ip = ip_with_mask.split('/')[0]
                    if ip != '127.0.0.1':  # Skip loopback
                        interfaces.append((current_iface, ip))
    except Exception as e:
        print(f"Error getting interfaces: {e}")

    return interfaces


class ConfigManager:
    """Manage application settings using XDG Base Directory specification"""

    def __init__(self):
        # Get XDG config directory (defaults to ~/.config)
        xdg_config_home = os.environ.get('XDG_CONFIG_HOME')
        if not xdg_config_home:
            xdg_config_home = os.path.join(Path.home(), '.config')

        # Create serialcom config directory
        self.config_dir = os.path.join(xdg_config_home, 'serialcom')
        os.makedirs(self.config_dir, exist_ok=True)

        # Config file path
        self.config_file = os.path.join(self.config_dir, 'settings.json')

        # Default settings
        self.defaults = {
            'port_type': 'USB',
            'baudrate': '9600',
            'databits': '8',
            'parity': 'None',
            'stopbits': '1',
            'flow': 'None',
            'vendor': 'Generic'
        }

        # Load settings
        self.settings = self.load()

    def load(self):
        """Load settings from file, return defaults if file doesn't exist"""
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    loaded = json.load(f)
                    # Merge with defaults (in case new settings were added)
                    return {**self.defaults, **loaded}
            except (json.JSONDecodeError, IOError) as e:
                print(f"Warning: Could not load settings: {e}")
                return self.defaults.copy()
        return self.defaults.copy()

    def save(self):
        """Save settings to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.settings, f, indent=4)
        except IOError as e:
            print(f"Warning: Could not save settings: {e}")

    def set(self, key, value):
        """Set a setting value and save"""
        self.settings[key] = value
        self.save()

    def get(self, key):
        """Get a setting value"""
        return self.settings.get(key, self.defaults.get(key))


class TerminalWidget(QTextEdit):
    """Terminal widget using pyte for proper VT100/ANSI emulation"""

    send_input = pyqtSignal(str)

    def __init__(self, parent=None, columns=120, lines=40):
        super().__init__(parent)
        self.setReadOnly(True)  # Terminal handles all input
        self.font_size = 10  # Default font size
        self.vendor = "Generic"  # Default vendor for syntax highlighting
        self.setFont(QFont("Monospace", self.font_size))

        # Prevent Tab from being used for focus navigation
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.setTabChangesFocus(False)

        # Initialize pyte terminal emulator
        self.screen = pyte.Screen(columns, lines)
        self.stream = pyte.Stream(self.screen)

        # Refresh timer for rendering
        self.refresh_timer = QTimer()
        self.refresh_timer.timeout.connect(self.render_screen)
        self.refresh_timer.start(50)  # Refresh every 50ms

        # Apply terminal styling
        self.setStyleSheet("""
            QTextEdit {
                background-color: #0a0a0a;
                color: #e0e0e0;
                border: none;
                padding: 10px;
            }
        """)

    def event(self, event):
        """Intercept Tab key before focus handling"""
        if event.type() == event.Type.KeyPress:
            if event.key() == Qt.Key.Key_Tab:
                # Handle Tab directly here, don't let it propagate
                self.send_input.emit('\t')
                event.accept()
                return True
        return super().event(event)

    def keyPressEvent(self, event: QKeyEvent):
        """Handle key press and send to picocom"""
        key = event.key()
        modifiers = event.modifiers()
        text = event.text()

        # Build key sequence to send
        sequence = ""

        # Handle Ctrl combinations
        if modifiers & Qt.KeyboardModifier.ControlModifier:
            if key == Qt.Key.Key_A:
                sequence = '\x01'
            elif key == Qt.Key.Key_C:
                sequence = '\x03'
            elif key == Qt.Key.Key_D:
                sequence = '\x04'
            elif key == Qt.Key.Key_H:
                sequence = '\x08'
            elif key == Qt.Key.Key_L:
                sequence = '\x0c'
            elif key == Qt.Key.Key_U:
                sequence = '\x15'
            elif key == Qt.Key.Key_X:
                sequence = '\x18'
            elif key == Qt.Key.Key_Z:
                sequence = '\x1a'

        # Handle special keys
        elif key == Qt.Key.Key_Return or key == Qt.Key.Key_Enter:
            sequence = '\r'
        elif key == Qt.Key.Key_Backspace:
            sequence = '\x7f'
        elif key == Qt.Key.Key_Tab:
            sequence = '\t'
        elif key == Qt.Key.Key_Up:
            sequence = '\x1b[A'
        elif key == Qt.Key.Key_Down:
            sequence = '\x1b[B'
        elif key == Qt.Key.Key_Right:
            sequence = '\x1b[C'
        elif key == Qt.Key.Key_Left:
            sequence = '\x1b[D'
        elif key == Qt.Key.Key_Home:
            sequence = '\x1b[H'
        elif key == Qt.Key.Key_End:
            sequence = '\x1b[F'
        elif key == Qt.Key.Key_Delete:
            sequence = '\x1b[3~'
        elif key == Qt.Key.Key_PageUp:
            sequence = '\x1b[5~'
        elif key == Qt.Key.Key_PageDown:
            sequence = '\x1b[6~'
        elif text:
            sequence = text

        # Send sequence to picocom
        if sequence:
            self.send_input.emit(sequence)

    def append_output(self, text):
        """Feed text to pyte terminal emulator"""
        self.stream.feed(text)

    def set_vendor(self, vendor):
        """Set the vendor for syntax highlighting"""
        self.vendor = vendor

    def get_vendor_keywords(self):
        """Get keywords specific to the selected vendor"""
        # Common keywords for all vendors
        common = ['vlan', 'ip', 'ipv6', 'address', 'shutdown', 'route', 'static',
                  'permit', 'deny', 'any', 'host', 'password', 'secret', 'description',
                  'protocol', 'snmp', 'community', 'version', 'dhcp', 'server', 'pool',
                  'gateway', 'dns', 'lease', 'ntp', 'authentication', 'key', 'logging']

        # Cisco IOS/IOS-XE specific
        cisco = common + [
            'interface', 'no', 'router', 'bgp', 'ospf', 'eigrp', 'rip', 'isis',
            'access-list', 'line', 'vty', 'console', 'enable', 'service', 'hostname',
            'banner', 'switchport', 'mode', 'trunk', 'access', 'native', 'allowed',
            'spanning-tree', 'portfast', 'bpduguard', 'channel-group', 'lacp', 'pagp',
            'ssh', 'telnet', 'http', 'https', 'aaa', 'radius', 'tacacs',
            'port-security', 'maximum', 'violation', 'sticky', 'aging', 'time',
            'show', 'running-config', 'startup-config', 'brief', 'status', 'summary',
            'detail', 'controllers', 'inventory', 'copy', 'write', 'erase', 'reload',
            'configure', 'terminal', 'end', 'exit', 'crypto', 'isakmp', 'ipsec'
        ]

        # Huawei VRP specific
        huawei = common + [
            'display', 'system-view', 'quit', 'return', 'save', 'undo', 'sysname',
            'interface', 'user-interface', 'authentication-mode', 'aaa', 'local-user',
            'privilege', 'level', 'acl', 'rule', 'source', 'destination', 'basic',
            'advanced', 'mac-address', 'port-isolate', 'eth-trunk', 'mode', 'lacp',
            'stp', 'bpdu', 'edged-port', 'ssh', 'telnet', 'client', 'server',
            'cipher', 'hmac', 'exchange', 'dh-exchange', 'header', 'dot1x', 'vlan',
            'batch', 'port', 'hybrid', 'trunk', 'access', 'voice-vlan', 'qinq',
            'current-configuration', 'saved-configuration', 'startup', 'next'
        ]

        # H3C Comware specific
        h3c = common + [
            'display', 'system-view', 'quit', 'return', 'save', 'undo', 'sysname',
            'interface', 'user-interface', 'authentication-mode', 'local-user',
            'authorization-mode', 'accounting-mode', 'acl', 'rule', 'basic', 'advanced',
            'link-aggregation', 'lacp', 'stp', 'bpdu-protection', 'edge-port',
            'ssh', 'telnet', 'server', 'port-security', 'mac-address', 'port',
            'hybrid', 'trunk', 'access', 'voice', 'current-configuration', 'lldp'
        ]

        # Juniper Junos specific
        juniper = common + [
            'set', 'delete', 'show', 'commit', 'rollback', 'configure', 'edit',
            'top', 'up', 'interfaces', 'protocols', 'routing-options', 'firewall',
            'security', 'zones', 'policies', 'nat', 'chassis', 'system', 'services'
        ]

        # D-Link specific
        dlink = common + [
            'create', 'delete', 'config', 'show', 'enable', 'disable', 'vlan',
            'ports', 'stp', 'igmp', 'snmp', 'fdb', 'address_binding', 'vlanname',
            'link_aggregation', 'group', 'master', 'member', 'lacp', 'state',
            'traffic_control', 'broadcast', 'multicast', 'unicast', 'action',
            'access_profile', 'access_list', 'packet_content_mask', 'profile_id',
            'bpdu_tunnel', 'tunnel_mac', 'loopdetect', 'recover_timer', 'interval',
            'safeguard_engine', 'rising_threshold', 'falling_threshold', 'mode',
            'download', 'upload', 'save', 'reboot', 'reset', 'factory_default',
            'ip_source_guard', 'verify_source', 'trust', 'max_dynamic_hosts',
            'traffic_segmentation', 'forward_list', 'block', 'mirror', 'session',
            'source', 'destination', 'port_mirror', 'flow_mirror', 'cpu_filter'
        ]

        # Brocade Fabric OS specific
        brocade = common + [
            'switchshow', 'switchname', 'switchdisable', 'switchenable', 'configshow',
            'configupload', 'configdownload', 'configdefault', 'fabricshow',
            'portshow', 'portcfgshow', 'portdisable', 'portenable', 'portname',
            'portcfgpersistentdisable', 'portcfgpersistentenable', 'switchportshow',
            'aliacreate', 'aliadd', 'aliremove', 'alidelete', 'alishow',
            'zonecreate', 'zoneadd', 'zoneremove', 'zonedelete', 'zoneshow',
            'cfgcreate', 'cfgadd', 'cfgremove', 'cfgdelete', 'cfgshow', 'cfgenable',
            'cfgdisable', 'cfgsave', 'cfgclear', 'defzone', 'nozoning',
            'firmwareshow', 'firmwaredownload', 'firmwaredownloadstatus', 'version',
            'licenseshow', 'licenseadd', 'licenseremove', 'licenseport',
            'ipaddrset', 'ipaddrshow', 'nsshow', 'nsallshow', 'nscamshow',
            'reboot', 'fastboot', 'hashow', 'failover', 'setcontext',
            'tsclockserver', 'tstimezone', 'date', 'uptime', 'diagshow', 'supportshow'
        ]

        # Datacom specific (Brazilian manufacturer)
        datacom = common + [
            'show', 'configure', 'interface', 'vlan', 'no', 'router', 'bgp', 'ospf',
            'eigrp', 'rip', 'access-list', 'line', 'vty', 'console', 'enable',
            'service', 'hostname', 'banner', 'switchport', 'mode', 'trunk', 'access',
            'spanning-tree', 'portfast', 'port-channel', 'lacp', 'etherchannel',
            'ssh', 'telnet', 'http', 'snmp-server', 'ntp', 'clock', 'timezone',
            'aaa', 'radius', 'tacacs', 'local-user', 'privilege', 'level',
            'qos', 'class-map', 'policy-map', 'service-policy', 'trust', 'dscp',
            'write', 'memory', 'reload', 'copy', 'running-config', 'startup-config',
            'erase', 'boot', 'system', 'flash', 'tftp', 'ftp', 'upload', 'download',
            'mac', 'mac-address-table', 'aging-time', 'storm-control', 'broadcast',
            'errdisable', 'recovery', 'cause', 'interval', 'speed', 'duplex', 'mtu',
            'description', 'default-gateway', 'ip-address', 'subnet-mask', 'vrf'
        ]

        # Fortinet FortiOS specific (Firewall)
        fortinet = common + [
            'config', 'end', 'next', 'edit', 'delete', 'show', 'get', 'set', 'unset',
            'execute', 'diagnose', 'purge', 'rename', 'clone', 'append', 'clear',
            'system', 'global', 'interface', 'admin', 'settings', 'ha', 'dns',
            'firewall', 'policy', 'address', 'addrgrp', 'service', 'custom',
            'schedule', 'recurring', 'onetime', 'ippool', 'vip', 'central-snat',
            'router', 'static', 'bgp', 'ospf', 'rip', 'multicast', 'policy-route',
            'vpn', 'ipsec', 'phase1-interface', 'phase2-interface', 'ssl',
            'ssl-web-portal', 'tunnel-mode', 'web-mode', 'certificate', 'local',
            'user', 'local', 'radius', 'ldap', 'group', 'peer', 'peergrp',
            'antivirus', 'profile', 'webfilter', 'ips', 'sensor', 'application',
            'list', 'control', 'emailfilter', 'dlp', 'filefilter', 'voip',
            'waf', 'profile', 'signature', 'protocol-options', 'ssh-filter',
            'log', 'fortianalyzer', 'forticloud', 'syslogd', 'memory', 'disk',
            'backup', 'restore', 'reboot', 'shutdown', 'factoryreset', 'revision',
            'debug', 'flow', 'trace', 'sniffer', 'packet', 'top', 'performance',
            'status', 'arp', 'session', 'route', 'neighbor', 'hardware', 'nic'
        ]

        # Generic - combination of all
        generic = list(set(common + cisco + huawei + h3c + dlink + brocade + datacom + fortinet))

        vendor_keywords = {
            'Generic': generic,
            'Cisco': cisco,
            'Huawei': huawei,
            'H3C': h3c,
            'Juniper': juniper,
            'D-Link': dlink,
            'Brocade': brocade,
            'Datacom': datacom,
            'Fortinet': fortinet
        }

        return vendor_keywords.get(self.vendor, generic)

    def apply_syntax_highlighting(self, text):
        """Apply syntax highlighting for network equipment commands"""
        import re

        # Don't highlight if text is empty or whitespace
        if not text.strip():
            return text

        # Escape HTML
        text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

        # Get keywords for selected vendor
        keywords = self.get_vendor_keywords()

        # Highlight keywords (cyan - vibrant)
        for keyword in keywords:
            # Match whole words only, case insensitive
            pattern = r'\b(' + re.escape(keyword) + r')\b'
            text = re.sub(pattern, r'<span style="color: #00ffff; font-weight: bold;">\1</span>', text, flags=re.IGNORECASE)

        # Highlight IP addresses (green - vibrant)
        ip_pattern = r'\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?:/\d{1,2})?)\b'
        text = re.sub(ip_pattern, r'<span style="color: #00ff00; font-weight: bold;">\1</span>', text)

        # Highlight MAC addresses (lime green - vibrant)
        mac_pattern = r'\b([0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}|[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2})\b'
        text = re.sub(mac_pattern, r'<span style="color: #00ff88; font-weight: bold;">\1</span>', text)

        # Highlight numbers (yellow - vibrant)
        # Avoid matching numbers already highlighted (in IP/MAC)
        number_pattern = r'(?<![\d\.])\b(\d+)\b(?![\d\.])'
        text = re.sub(number_pattern, r'<span style="color: #ffff00;">\1</span>', text)

        # Highlight prompts (magenta - vibrant) - patterns like [SWITCH]#, Router>, etc.
        prompt_pattern = r'^([\[\<]?[A-Za-z0-9_-]+[\]\>]?[#&gt;])'
        text = re.sub(prompt_pattern, r'<span style="color: #ff00ff; font-weight: bold;">\1</span>', text, flags=re.MULTILINE)

        return text

    def get_ansi_color(self, color, is_background=False):
        """Convert pyte color to HTML color code"""
        # ANSI color palette (standard 16 colors)
        ansi_colors = {
            'black': '#000000',
            'red': '#cd0000',
            'green': '#00cd00',
            'brown': '#cdcd00',
            'blue': '#0000ee',
            'magenta': '#cd00cd',
            'cyan': '#00cdcd',
            'white': '#e5e5e5',
            # Bright variants
            'brightblack': '#7f7f7f',
            'brightred': '#ff0000',
            'brightgreen': '#00ff00',
            'brightyellow': '#ffff00',
            'brightblue': '#5c5cff',
            'brightmagenta': '#ff00ff',
            'brightcyan': '#00ffff',
            'brightwhite': '#ffffff',
        }

        # Default colors
        default_fg = '#e0e0e0'
        default_bg = 'transparent'

        if color == 'default':
            return default_bg if is_background else default_fg

        # Named color
        if isinstance(color, str):
            return ansi_colors.get(color, default_bg if is_background else default_fg)

        # 256-color palette (simplified - using approximations)
        if isinstance(color, int):
            if color < 16:
                # Standard colors
                color_names = ['black', 'red', 'green', 'brown', 'blue', 'magenta', 'cyan', 'white',
                              'brightblack', 'brightred', 'brightgreen', 'brightyellow',
                              'brightblue', 'brightmagenta', 'brightcyan', 'brightwhite']
                return ansi_colors.get(color_names[color], default_bg if is_background else default_fg)
            elif color < 232:
                # 216 color cube (6x6x6)
                color -= 16
                r = (color // 36) * 51
                g = ((color % 36) // 6) * 51
                b = (color % 6) * 51
                return f'#{r:02x}{g:02x}{b:02x}'
            else:
                # Grayscale
                gray = 8 + (color - 232) * 10
                return f'#{gray:02x}{gray:02x}{gray:02x}'

        return default_bg if is_background else default_fg

    def render_screen(self):
        """Render pyte screen buffer to QTextEdit with ANSI color support"""
        # Get cursor position from pyte
        cursor_x = self.screen.cursor.x
        cursor_y = self.screen.cursor.y

        # Build HTML content with cursor highlighting and ANSI colors
        html_lines = []
        html_lines.append('<pre style="margin: 0; padding: 0; line-height: 1.2;">')

        for y in range(self.screen.lines):
            # Render character by character to preserve spacing
            line = ""
            for x in range(self.screen.columns):
                char = self.screen.buffer[y][x]
                char_data = char.data

                # Escape HTML special characters and preserve spaces
                char_data = char_data.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace(' ', '&nbsp;')

                # Get ANSI colors from character attributes
                fg_color = self.get_ansi_color(char.fg, is_background=False)
                bg_color = self.get_ansi_color(char.bg, is_background=True)

                # Build style string
                styles = [f'color: {fg_color}']
                if bg_color != 'transparent':
                    styles.append(f'background-color: {bg_color}')
                if char.bold:
                    styles.append('font-weight: bold')
                if char.italics:
                    styles.append('font-style: italic')
                if char.underscore:
                    styles.append('text-decoration: underline')
                if char.reverse:
                    # Swap foreground and background
                    styles = [f'color: {bg_color if bg_color != "transparent" else "#0a0a0a"}',
                             f'background-color: {fg_color}']

                # Highlight cursor position (override colors)
                if y == cursor_y and x == cursor_x:
                    if char_data == '&nbsp;' or char_data == '':
                        char_data = 'â–ˆ'
                        styles = ['color: #e0e0e0', 'background-color: transparent']
                    else:
                        styles = ['color: #0a0a0a', 'background-color: #e0e0e0']

                style_str = '; '.join(styles)
                line += f'<span style="{style_str}">{char_data}</span>'

            html_lines.append(line)

        html_lines.append('</pre>')
        new_html = '\n'.join(html_lines)

        # Save scroll position - use tolerance for "at bottom" detection
        scrollbar = self.verticalScrollBar()
        # Consider "at bottom" if within 10 pixels of maximum
        at_bottom = scrollbar.maximum() - scrollbar.value() <= 10

        # Update text with HTML
        self.setHtml(new_html)

        # Auto-scroll to bottom if user was at or near bottom
        if at_bottom:
            # Move cursor to end
            cursor = self.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            self.setTextCursor(cursor)
            # Ensure cursor is visible
            self.ensureCursorVisible()
            # Force scroll to maximum
            scrollbar.setValue(scrollbar.maximum())

    def increase_font_size(self):
        """Increase terminal font size"""
        if self.font_size < 24:  # Maximum font size limit
            self.font_size += 1
            self.setFont(QFont("Monospace", self.font_size))

    def decrease_font_size(self):
        """Decrease terminal font size"""
        if self.font_size > 6:  # Minimum font size limit
            self.font_size -= 1
            self.setFont(QFont("Monospace", self.font_size))


class TerminalDialog(QDialog):
    """Dialog window containing the embedded terminal"""
    
    def __init__(self, parent=None, config=None):
        super().__init__(parent)
        self.setWindowTitle("SerialCom Terminal")
        self.setMinimumSize(1200, 700)
        self.process = None
        self.sudo_process = None
        self.config = config

        self.init_ui()

    def get_arrow_icon_path(self):
        """Get the path to arrow_down.svg for different installation types"""
        # Check for Flatpak
        if os.path.exists('/app/share/io.github.benjamimgois.serialcom/arrow_down.svg'):
            return '/app/share/io.github.benjamimgois.serialcom/arrow_down.svg'
        # Check for AppImage
        elif os.environ.get('APPDIR'):
            appdir = os.environ.get('APPDIR')
            return os.path.join(appdir, 'usr/share/serialcom/arrow_down.svg')
        # Local installation or development
        else:
            # Try current directory first
            local_path = os.path.join(os.path.dirname(__file__), 'arrow_down.svg')
            if os.path.exists(local_path):
                return local_path
            # Try assets directory
            assets_path = os.path.join(os.path.dirname(__file__), 'assets/arrow_down.svg')
            if os.path.exists(assets_path):
                return assets_path
            # Fallback
            return local_path

    def init_ui(self):
        """Initialize the terminal dialog UI"""
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Terminal widget
        self.terminal = TerminalWidget()
        self.terminal.send_input.connect(self.send_to_process)
        layout.addWidget(self.terminal)
        
        # Control buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(10, 5, 10, 10)

        # Font size buttons
        self.font_decrease_btn = QPushButton("A-")
        self.font_decrease_btn.setMinimumHeight(35)
        self.font_decrease_btn.setMaximumWidth(50)
        self.font_decrease_btn.setFont(QFont("Sans Serif", 10, QFont.Weight.Bold))
        self.font_decrease_btn.clicked.connect(self.terminal.decrease_font_size)
        self.font_decrease_btn.setStyleSheet("""
            QPushButton {
                background-color: #89b4fa;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #74a0e8;
            }
            QPushButton:pressed {
                background-color: #5f8cd6;
            }
        """)

        self.font_increase_btn = QPushButton("A+")
        self.font_increase_btn.setMinimumHeight(35)
        self.font_increase_btn.setMaximumWidth(50)
        self.font_increase_btn.setFont(QFont("Sans Serif", 10, QFont.Weight.Bold))
        self.font_increase_btn.clicked.connect(self.terminal.increase_font_size)
        self.font_increase_btn.setStyleSheet("""
            QPushButton {
                background-color: #89b4fa;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #74a0e8;
            }
            QPushButton:pressed {
                background-color: #5f8cd6;
            }
        """)

        self.disconnect_btn = QPushButton("DISCONNECT")
        self.disconnect_btn.setMinimumHeight(35)
        self.disconnect_btn.setFont(QFont("Sans Serif", 10, QFont.Weight.Bold))
        self.disconnect_btn.clicked.connect(self.disconnect)
        self.disconnect_btn.setStyleSheet("""
            QPushButton {
                background-color: #f38ba8;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #f26d8f;
            }
            QPushButton:pressed {
                background-color: #d95a7a;
            }
        """)

        # Vendor selector
        vendor_label = QLabel("Equipment:")
        vendor_label.setStyleSheet("""
            QLabel {
                color: #b0b0b0;
                font-size: 10pt;
                padding: 0 8px;
            }
        """)

        # Get arrow icon path (same method as main window)
        arrow_path = self.get_arrow_icon_path()

        self.vendor_combo = QComboBox()
        self.vendor_combo.addItems(['Generic', 'Cisco', 'Huawei', 'H3C', 'Juniper', 'D-Link', 'Brocade', 'Datacom', 'Fortinet'])

        # Load saved vendor selection
        if self.config:
            saved_vendor = self.config.get('vendor')
            index = self.vendor_combo.findText(saved_vendor)
            if index >= 0:
                self.vendor_combo.setCurrentIndex(index)
        else:
            self.vendor_combo.setCurrentText('Generic')

        self.vendor_combo.currentTextChanged.connect(self.change_vendor)
        self.vendor_combo.setMinimumHeight(35)
        self.vendor_combo.setMaximumWidth(130)
        self.vendor_combo.setStyleSheet(f"""
            QComboBox {{
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 2px solid #5a5a5a;
                border-radius: 6px;
                padding: 5px 28px 5px 10px;
                font-size: 10pt;
            }}
            QComboBox:hover {{
                border: 2px solid #707070;
                background-color: #454545;
            }}
            QComboBox:focus {{
                border: 2px solid #707070;
            }}
            QComboBox::drop-down {{
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 25px;
                border-left: 1px solid #5a5a5a;
                border-top-right-radius: 5px;
                border-bottom-right-radius: 5px;
                background-color: transparent;
            }}
            QComboBox::down-arrow {{
                image: url({arrow_path});
                width: 12px;
                height: 12px;
            }}
            QComboBox QAbstractItemView {{
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 2px solid #5a5a5a;
                selection-background-color: #5a5a5a;
                selection-color: #ffffff;
                outline: none;
                padding: 4px;
            }}
            QComboBox QAbstractItemView::item {{
                min-height: 28px;
                padding: 5px;
            }}
            QComboBox QAbstractItemView::item:hover {{
                background-color: #4a4a4a;
            }}
        """)

        button_layout.addWidget(self.font_decrease_btn)
        button_layout.addSpacing(10)  # Add space between font buttons
        button_layout.addWidget(self.font_increase_btn)
        button_layout.addSpacing(20)  # Add space before vendor selector
        button_layout.addWidget(vendor_label)
        button_layout.addWidget(self.vendor_combo)
        button_layout.addStretch()
        button_layout.addWidget(self.disconnect_btn)

        layout.addLayout(button_layout)
        self.setLayout(layout)

    def change_vendor(self, vendor):
        """Change the syntax highlighting vendor"""
        self.terminal.set_vendor(vendor)
        # Save vendor selection
        if self.config:
            self.config.set('vendor', vendor)

    def start_picocom(self, cmd):
        """Start picocom process with sudo"""
        # Ask for sudo password using graphical dialog
        password, ok = QInputDialog.getText(
            self,
            "Sudo Password Required",
            "Please enter your sudo password to access serial port:",
            QLineEdit.EchoMode.Password
        )

        if not ok or not password:
            self.terminal.append_output("[CANCELLED] Password not provided\n")
            return False

        # Create the process
        self.process = QProcess(self)
        self.process.readyReadStandardOutput.connect(self.handle_stdout)
        self.process.readyReadStandardError.connect(self.handle_stderr)
        self.process.finished.connect(self.process_finished)

        # Build sudo command
        picocom_cmd = ' '.join(cmd)
        full_cmd = ['sudo', '-S'] + cmd

        # Start process
        self.terminal.append_output(f"Starting: {picocom_cmd}\n")

        self.process.start(full_cmd[0], full_cmd[1:])

        if not self.process.waitForStarted(3000):
            self.terminal.append_output("\n[ERROR] Failed to start picocom\n")
            return False

        # Send password to sudo
        self.process.write((password + '\n').encode())
        password = None  # Clear password from memory

        self.terminal.append_output("Connecting...\n\n")

        return True

    def start_debug_mode(self):
        """Start terminal in debug mode with simulated Cisco router output"""
        self.setWindowTitle("SerialCom Terminal [DEBUG MODE]")

        # Simulated Cisco router configuration
        cisco_output = """\r
\r
Router>\x1b[33menable\x1b[0m\r
Password: \r
Router#\x1b[33mshow running-config\x1b[0m\r
Building configuration...\r
\r
Current configuration : 1584 bytes\r
!\r
! Last configuration change at 14:32:15 UTC Mon Jan 15 2024\r
!\r
version 15.1\r
service timestamps debug datetime msec\r
service timestamps log datetime msec\r
no service password-encryption\r
!\r
hostname \x1b[36mRouter\x1b[0m\r
!\r
boot-start-marker\r
boot-end-marker\r
!\r
enable secret 5 $1$mERr$hx5rVt7rPNoS4wqbXKX7m0\r
!\r
no aaa new-model\r
!\r
interface \x1b[36mGigabitEthernet0/0\x1b[0m\r
 description \x1b[32mWAN Connection to ISP\x1b[0m\r
 ip address \x1b[33m203.0.113.1\x1b[0m \x1b[33m255.255.255.252\x1b[0m\r
 duplex auto\r
 speed auto\r
!\r
interface \x1b[36mGigabitEthernet0/1\x1b[0m\r
 description \x1b[32mLAN Network\x1b[0m\r
 ip address \x1b[33m192.168.1.1\x1b[0m \x1b[33m255.255.255.0\x1b[0m\r
 duplex auto\r
 speed auto\r
!\r
interface \x1b[36mGigabitEthernet0/2\x1b[0m\r
 description \x1b[32mDMZ Network\x1b[0m\r
 ip address \x1b[33m10.0.0.1\x1b[0m \x1b[33m255.255.255.0\x1b[0m\r
 duplex auto\r
 speed auto\r
!\r
ip route \x1b[33m0.0.0.0\x1b[0m \x1b[33m0.0.0.0\x1b[0m \x1b[33m203.0.113.2\x1b[0m\r
!\r
ip access-list extended \x1b[36mINBOUND_ACL\x1b[0m\r
 \x1b[32mpermit\x1b[0m tcp any any eq \x1b[33m22\x1b[0m\r
 \x1b[32mpermit\x1b[0m tcp any any eq \x1b[33m80\x1b[0m\r
 \x1b[32mpermit\x1b[0m tcp any any eq \x1b[33m443\x1b[0m\r
 \x1b[31mdeny\x1b[0m ip any any log\r
!\r
line con 0\r
 logging synchronous\r
line aux 0\r
line vty 0 4\r
 login local\r
 transport input ssh\r
!\r
end\r
\r
Router#\x1b[33mshow ip interface brief\x1b[0m\r
Interface              IP-Address      OK? Method Status                Protocol\r
GigabitEthernet0/0     \x1b[33m203.0.113.1\x1b[0m     YES NVRAM  \x1b[32mup\x1b[0m                    \x1b[32mup\x1b[0m\r
GigabitEthernet0/1     \x1b[33m192.168.1.1\x1b[0m     YES NVRAM  \x1b[32mup\x1b[0m                    \x1b[32mup\x1b[0m\r
GigabitEthernet0/2     \x1b[33m10.0.0.1\x1b[0m        YES NVRAM  \x1b[32mup\x1b[0m                    \x1b[32mup\x1b[0m\r
\r
Router#\x1b[33mshow version\x1b[0m\r
Cisco IOS Software, C2900 Software (C2900-UNIVERSALK9-M), Version 15.1(4)M4\r
Technical Support: http://www.cisco.com/techsupport\r
Copyright (c) 1986-2012 by Cisco Systems, Inc.\r
\r
ROM: System Bootstrap, Version 15.0(1r)M9\r
\r
Router uptime is \x1b[33m2 days, 14 hours, 32 minutes\x1b[0m\r
System returned to ROM by power-on\r
System image file is "flash:c2900-universalk9-mz.SPA.151-4.M4.bin"\r
\r
Cisco CISCO2911/K9 (revision 1.0) with \x1b[33m512000K/62464K\x1b[0m bytes of memory.\r
Processor board ID FTX1524A0WZ\r
3 Gigabit Ethernet interfaces\r
DRAM configuration is 64 bits wide with parity disabled.\r
256K bytes of non-volatile configuration memory.\r
\r
Router#_\r
"""

        # Feed the simulated output to the terminal
        self.terminal.append_output(cisco_output)

    def send_to_process(self, text):
        """Send input to the picocom process"""
        if self.process and self.process.state() == QProcess.ProcessState.Running:
            self.process.write(text.encode())
    
    def handle_stdout(self):
        """Handle standard output from picocom"""
        if self.process:
            data = self.process.readAllStandardOutput()
            text = bytes(data).decode('utf-8', errors='replace')
            self.terminal.append_output(text)
    
    def handle_stderr(self):
        """Handle standard error from picocom"""
        if self.process:
            data = self.process.readAllStandardError()
            text = bytes(data).decode('utf-8', errors='replace')
            self.terminal.append_output(text)
    
    def process_finished(self, exit_code, exit_status):
        """Handle process termination"""
        self.terminal.append_output(f"\n\n[Process terminated with exit code {exit_code}]\n")
        self.terminal.append_output("You can close this window.\n")
        self.disconnect_btn.setText("CLOSE")
    
    def disconnect(self):
        """Disconnect from serial port"""
        if self.process and self.process.state() == QProcess.ProcessState.Running:
            # Send Ctrl+A Ctrl+X to exit picocom gracefully
            self.process.write(b'\x01\x18')
            
            # Wait a bit for graceful exit
            if not self.process.waitForFinished(2000):
                # Force terminate if needed
                self.process.terminate()
                if not self.process.waitForFinished(1000):
                    self.process.kill()
        
        self.close()
    
    def closeEvent(self, event):
        """Handle window close event"""
        if self.process and self.process.state() == QProcess.ProcessState.Running:
            reply = QMessageBox.question(
                self,
                'Confirm Exit',
                'Connection is still active. Disconnect and close?',
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                self.disconnect()
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()


class SerialTerminalGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(f"SerialCom v{VERSION}")
        self.setFixedSize(550, 880)
        self.terminal_dialog = None
        self.config = ConfigManager()
        self.init_ui()
        self.apply_styles()
        self.load_settings()

    def init_ui(self):
        """Initialize the user interface"""
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main layout
        main_layout = QVBoxLayout()
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(20, 20, 20, 20)

        # Standard width for all comboboxes
        combo_width = 200

        # Port configuration group
        port_group = QGroupBox("Port Configuration")
        port_layout = QFormLayout()
        port_layout.setVerticalSpacing(15)
        port_layout.setContentsMargins(15, 15, 15, 15)
        port_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        port_layout.setFormAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Port type
        self.port_type = QComboBox()
        self.port_type.addItems(['USB', 'Serial'])
        self.port_type.setCurrentIndex(0)
        self.port_type.setFixedWidth(combo_width)
        self.port_type.setToolTip("Select the type of serial port")
        self.port_type.currentIndexChanged.connect(self.update_port_list)
        port_layout.addRow("Type:", self.port_type)

        # Port
        self.port = QComboBox()
        self.port.setFixedWidth(combo_width)
        self.port.setToolTip("Select the serial port to connect")
        port_layout.addRow("Port:", self.port)

        port_group.setLayout(port_layout)

        # Add shadow effect to port group
        shadow1 = QGraphicsDropShadowEffect()
        shadow1.setBlurRadius(15)
        shadow1.setXOffset(0)
        shadow1.setYOffset(2)
        shadow1.setColor(QColor(0, 0, 0, 30))
        port_group.setGraphicsEffect(shadow1)

        main_layout.addWidget(port_group)

        # Communication parameters group
        comm_group = QGroupBox("Communication Parameters")
        comm_layout = QFormLayout()
        comm_layout.setVerticalSpacing(15)
        comm_layout.setContentsMargins(15, 15, 15, 15)
        comm_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        comm_layout.setFormAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Baud Rate - MAIN FIELD (highlighted)
        velocity_label = QLabel("Baud Rate:")
        velocity_font = QFont("Sans Serif", 10, QFont.Weight.Bold)
        velocity_label.setFont(velocity_font)
        velocity_label.setStyleSheet("color: #2e7d32;")

        self.baudrate = QComboBox()
        self.baudrate.addItems([
            '300', '1200', '2400', '4800', '9600', '19200',
            '38400', '57600', '115200', '230400', '460800', '921600'
        ])
        self.baudrate.setCurrentText('9600')
        self.baudrate.setFixedWidth(combo_width)
        self.baudrate.setToolTip("Communication speed in bits per second")
        self.baudrate.setStyleSheet("""
            QComboBox {
                border: 2px solid #4caf50;
                background-color: #f1f8e9;
            }
            QComboBox:hover {
                border: 2px solid #2e7d32;
                background-color: #e8f5e9;
            }
        """)
        comm_layout.addRow(velocity_label, self.baudrate)

        # Data bits
        self.databits = QComboBox()
        self.databits.addItems(['5', '6', '7', '8'])
        self.databits.setCurrentText('8')
        self.databits.setFixedWidth(combo_width)
        self.databits.setToolTip("Number of data bits per character (usually 8)")
        comm_layout.addRow("Data Bits:", self.databits)

        # Parity
        self.parity = QComboBox()
        self.parity.addItems(['None', 'Even', 'Odd'])
        self.parity.setCurrentText('None')
        self.parity.setFixedWidth(combo_width)
        self.parity.setToolTip("Error detection method (usually None)")
        comm_layout.addRow("Parity:", self.parity)

        # Stop bits
        self.stopbits = QComboBox()
        self.stopbits.addItems(['1', '2'])
        self.stopbits.setCurrentText('1')
        self.stopbits.setFixedWidth(combo_width)
        self.stopbits.setToolTip("Number of stop bits (usually 1)")
        comm_layout.addRow("Stop Bits:", self.stopbits)

        # Flow control
        self.flow = QComboBox()
        self.flow.addItems(['None', 'Hardware (RTS/CTS)', 'Software (XON/XOFF)'])
        self.flow.setCurrentText('None')
        self.flow.setFixedWidth(combo_width)
        self.flow.setToolTip("Flow control method (usually None)")
        comm_layout.addRow("Flow Control:", self.flow)

        comm_group.setLayout(comm_layout)

        # Add shadow effect to comm group
        shadow2 = QGraphicsDropShadowEffect()
        shadow2.setBlurRadius(15)
        shadow2.setXOffset(0)
        shadow2.setYOffset(2)
        shadow2.setColor(QColor(0, 0, 0, 30))
        comm_group.setGraphicsEffect(shadow2)

        main_layout.addWidget(comm_group)

        # TFTP Server group
        tftp_group = QGroupBox("TFTP Server")
        tftp_layout = QFormLayout()
        tftp_layout.setVerticalSpacing(12)
        tftp_layout.setContentsMargins(15, 15, 15, 15)
        tftp_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        tftp_layout.setFormAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Network interface selector
        self.tftp_interface = QComboBox()
        self.tftp_interface.setFixedWidth(combo_width)
        self.tftp_interface.setToolTip("Select network interface for TFTP server")
        self.update_network_interfaces()
        tftp_layout.addRow("Interface:", self.tftp_interface)

        # TFTP directory with browse button and start button
        tftp_dir_layout = QHBoxLayout()
        tftp_dir_layout.setContentsMargins(0, 0, 0, 0)
        tftp_dir_layout.setSpacing(2)

        self.tftp_directory = QLineEdit()
        self.tftp_directory.setFixedWidth(combo_width)
        self.tftp_directory.setText(os.path.expanduser('~'))
        self.tftp_directory.setToolTip("Directory containing firmware files")

        self.tftp_browse_btn = QPushButton()
        self.tftp_browse_btn.setFixedSize(28, 28)
        self.tftp_browse_btn.setIcon(self.style().standardIcon(self.style().StandardPixmap.SP_DirOpenIcon))
        self.tftp_browse_btn.setToolTip("Browse for directory")
        self.tftp_browse_btn.clicked.connect(self.browse_tftp_directory)

        self.tftp_btn = QPushButton("Start TFTP")
        self.tftp_btn.setFixedHeight(28)
        self.tftp_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.tftp_btn.clicked.connect(self.toggle_tftp_server)
        self.tftp_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 4px 16px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)

        tftp_dir_layout.addWidget(self.tftp_directory)
        tftp_dir_layout.addWidget(self.tftp_browse_btn)
        tftp_dir_layout.addSpacing(8)
        tftp_dir_layout.addWidget(self.tftp_btn)
        tftp_dir_layout.addStretch()

        tftp_dir_widget = QWidget()
        tftp_dir_widget.setContentsMargins(0, 0, 0, 0)
        tftp_dir_widget.setLayout(tftp_dir_layout)
        tftp_layout.addRow("Directory:", tftp_dir_widget)

        tftp_group.setLayout(tftp_layout)

        # Add shadow effect to tftp group
        shadow3 = QGraphicsDropShadowEffect()
        shadow3.setBlurRadius(15)
        shadow3.setXOffset(0)
        shadow3.setYOffset(2)
        shadow3.setColor(QColor(0, 0, 0, 30))
        tftp_group.setGraphicsEffect(shadow3)

        main_layout.addWidget(tftp_group)

        # Initialize TFTP server instance
        self.tftp_server = None

        # Debug mode checkbox
        self.debug_checkbox = QCheckBox("Debug Mode (simulate Cisco router)")
        self.debug_checkbox.setToolTip("Enable to test terminal without a real device")
        self.debug_checkbox.setStyleSheet("color: #606060; font-size: 9pt;")
        main_layout.addWidget(self.debug_checkbox)

        # Connect button
        self.connect_btn = QPushButton("CONNECT")
        self.connect_btn.setMinimumHeight(45)
        self.connect_btn.setFont(QFont("Sans Serif", 11, QFont.Weight.Bold))
        self.connect_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.connect_btn.clicked.connect(self.connect)
        main_layout.addWidget(self.connect_btn)

        # Status with LED indicator
        status_layout = QHBoxLayout()
        status_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        status_layout.setSpacing(8)

        self.status_led = QLabel("â—")
        self.status_led.setStyleSheet("color: #4caf50; font-size: 14px;")

        self.status_label = QLabel("Ready to connect")
        self.status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")

        status_layout.addWidget(self.status_led)
        status_layout.addWidget(self.status_label)

        status_widget = QWidget()
        status_widget.setLayout(status_layout)
        main_layout.addWidget(status_widget)

        central_widget.setLayout(main_layout)

        # Update port list
        self.update_port_list()

    def get_arrow_icon_path(self):
        """Get the path to arrow_down.svg for different installation types"""
        # Check for Flatpak
        if os.path.exists('/app/share/io.github.benjamimgois.serialcom/arrow_down.svg'):
            return '/app/share/io.github.benjamimgois.serialcom/arrow_down.svg'
        # Check for AppImage
        elif os.environ.get('APPDIR'):
            appdir = os.environ.get('APPDIR')
            return os.path.join(appdir, 'usr/share/serialcom/arrow_down.svg')
        # Local installation or development
        else:
            # Try current directory first
            local_path = os.path.join(os.path.dirname(__file__), 'arrow_down.svg')
            if os.path.exists(local_path):
                return local_path
            # Try assets directory
            assets_path = os.path.join(os.path.dirname(__file__), 'assets/arrow_down.svg')
            if os.path.exists(assets_path):
                return assets_path
            # Fallback
            return local_path

    def apply_styles(self):
        """Apply modern light theme to the application"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f0f0f0;
            }
            QGroupBox {
                font-weight: bold;
                border: 1px solid #e0e0e0;
                border-radius: 10px;
                margin-top: 12px;
                padding-top: 15px;
                background-color: #ffffff;
                color: #2c2c2c;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 12px;
                padding: 0 8px;
                color: #606060;
            }
            QComboBox {
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                padding: 6px 28px 6px 10px;
                background-color: #fafafa;
                min-height: 28px;
                color: #2c2c2c;
                font-size: 10pt;
            }
            QComboBox::drop-down {
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 25px;
                border-left: 1px solid #d0d0d0;
                border-top-right-radius: 5px;
                border-bottom-right-radius: 5px;
                background-color: transparent;
            }
            QComboBox::down-arrow {
                image: url(""" + self.get_arrow_icon_path() + """);
                width: 12px;
                height: 12px;
            }
            QComboBox:hover {
                border: 1px solid #a0a0a0;
                background-color: #ffffff;
            }
            QComboBox:focus {
                border: 2px solid #4caf50;
            }
            QComboBox QAbstractItemView {
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                background-color: #ffffff;
                selection-background-color: #e8f5e9;
                selection-color: #2c2c2c;
                color: #2c2c2c;
                padding: 4px;
                outline: none;
            }
            QComboBox QAbstractItemView::item {
                padding: 6px;
                min-height: 24px;
            }
            QComboBox QAbstractItemView::item:hover {
                background-color: #f5f5f5;
            }
            QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 8px;
                padding: 12px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #43a047;
            }
            QPushButton:pressed {
                background-color: #388e3c;
            }
            QLabel {
                color: #2c2c2c;
            }
            QFormLayout QLabel {
                color: #4a4a4a;
            }
            QMessageBox {
                background-color: #ffffff;
            }
            QMessageBox QLabel {
                color: #2c2c2c;
                font-size: 10pt;
            }
            QMessageBox QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px 16px;
                min-width: 80px;
            }
            QMessageBox QPushButton:hover {
                background-color: #43a047;
            }
            QToolTip {
                background-color: #424242;
                color: #ffffff;
                border: none;
                border-radius: 4px;
                padding: 5px 8px;
                font-size: 9pt;
            }
        """)

    def load_settings(self):
        """Load saved settings and apply to ComboBoxes"""
        # Load and set port type
        port_type = self.config.get('port_type')
        index = self.port_type.findText(port_type)
        if index >= 0:
            self.port_type.setCurrentIndex(index)

        # Load and set baudrate
        baudrate = self.config.get('baudrate')
        index = self.baudrate.findText(baudrate)
        if index >= 0:
            self.baudrate.setCurrentIndex(index)

        # Load and set databits
        databits = self.config.get('databits')
        index = self.databits.findText(databits)
        if index >= 0:
            self.databits.setCurrentIndex(index)

        # Load and set parity
        parity = self.config.get('parity')
        index = self.parity.findText(parity)
        if index >= 0:
            self.parity.setCurrentIndex(index)

        # Load and set stopbits
        stopbits = self.config.get('stopbits')
        index = self.stopbits.findText(stopbits)
        if index >= 0:
            self.stopbits.setCurrentIndex(index)

        # Load and set flow
        flow = self.config.get('flow')
        index = self.flow.findText(flow)
        if index >= 0:
            self.flow.setCurrentIndex(index)

        # Connect signals to save settings when changed
        self.port_type.currentTextChanged.connect(lambda text: self.config.set('port_type', text))
        self.baudrate.currentTextChanged.connect(lambda text: self.config.set('baudrate', text))
        self.databits.currentTextChanged.connect(lambda text: self.config.set('databits', text))
        self.parity.currentTextChanged.connect(lambda text: self.config.set('parity', text))
        self.stopbits.currentTextChanged.connect(lambda text: self.config.set('stopbits', text))
        self.flow.currentTextChanged.connect(lambda text: self.config.set('flow', text))

    def update_port_list(self):
        """Update the list of available ports"""
        self.port.clear()

        port_type = self.port_type.currentText()

        # Use glob to search for ports based on type
        if port_type == 'Serial':
            pattern = '/dev/ttyS*'
        else:  # USB
            pattern = '/dev/ttyUSB*'

        ports = sorted(glob.glob(pattern))

        if ports:
            self.port.addItems(ports)
            self.status_label.setText(f"{len(ports)} port(s) found")
            self.status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #4caf50; font-size: 14px;")
        else:
            self.port.addItem("No ports found")
            self.status_label.setText("No serial ports available")
            self.status_label.setStyleSheet("color: #ff9800; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #ff9800; font-size: 14px;")

    def update_network_interfaces(self):
        """Update the list of network interfaces"""
        self.tftp_interface.clear()
        interfaces = get_network_interfaces()

        if interfaces:
            for iface, ip in interfaces:
                self.tftp_interface.addItem(f"{iface} ({ip})", ip)
        else:
            self.tftp_interface.addItem("No interfaces found", "")

    def browse_tftp_directory(self):
        """Open dialog to select TFTP directory"""
        directory = QFileDialog.getExistingDirectory(
            self,
            "Select TFTP Directory",
            self.tftp_directory.text()
        )
        if directory:
            self.tftp_directory.setText(directory)

    def toggle_tftp_server(self):
        """Start or stop the TFTP server"""
        if self.tftp_server and self.tftp_server.is_running():
            # Stop server
            self.tftp_server.stop()
            self.tftp_btn.setText("Start TFTP")
            self.tftp_btn.setStyleSheet("""
                QPushButton {
                    background-color: #2196F3;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-weight: bold;
                }
                QPushButton:hover {
                    background-color: #1976D2;
                }
            """)
            self.tftp_interface.setEnabled(True)
            self.tftp_directory.setEnabled(True)
            self.tftp_browse_btn.setEnabled(True)
        else:
            # Get selected interface IP
            ip = self.tftp_interface.currentData()
            if not ip:
                QMessageBox.warning(self, "Warning", "No network interface selected")
                return

            directory = self.tftp_directory.text()
            if not os.path.isdir(directory):
                QMessageBox.warning(self, "Warning", "Invalid TFTP directory")
                return

            # Start server (port 69 requires root, use 6969 as alternative)
            self.tftp_server = TFTPServer(host=ip, port=69, root_dir=directory)

            if not self.tftp_server.start():
                # Try alternative port
                self.tftp_server = TFTPServer(host=ip, port=6969, root_dir=directory)
                if not self.tftp_server.start():
                    QMessageBox.critical(
                        self,
                        "Error",
                        "Failed to start TFTP server.\n\n"
                        "Port 69 requires root privileges.\n"
                        "Try running with sudo or use a different port."
                    )
                    return
                else:
                    QMessageBox.information(
                        self,
                        "TFTP Server",
                        f"TFTP server started on {ip}:6969\n"
                        f"(Port 69 requires root, using alternative port)\n\n"
                        f"Directory: {directory}"
                    )
            else:
                QMessageBox.information(
                    self,
                    "TFTP Server",
                    f"TFTP server started on {ip}:69\n\n"
                    f"Directory: {directory}"
                )

            self.tftp_btn.setText("Stop TFTP")
            self.tftp_btn.setStyleSheet("""
                QPushButton {
                    background-color: #f44336;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-weight: bold;
                }
                QPushButton:hover {
                    background-color: #d32f2f;
                }
            """)
            self.tftp_interface.setEnabled(False)
            self.tftp_directory.setEnabled(False)
            self.tftp_browse_btn.setEnabled(False)

    def build_picocom_command(self):
        """Build the picocom command with configured parameters"""
        port = self.port.currentText()

        if 'No ports found' in port or not port:
            return None

        baudrate = self.baudrate.currentText()
        databits = self.databits.currentText()

        # Parity
        parity_map = {'None': 'n', 'Even': 'e', 'Odd': 'o'}
        parity = parity_map[self.parity.currentText()]

        stopbits = self.stopbits.currentText()

        # Flow control
        flow_type = self.flow.currentText()
        if 'Hardware' in flow_type:
            flow = 'h'
        elif 'Software' in flow_type:
            flow = 's'
        else:
            flow = 'n'

        # Picocom command
        cmd = [
            'picocom',
            '-b', baudrate,
            '-d', databits,
            '-p', parity,
            '-f', flow,
            port
        ]

        # Add stop bits if 2
        if stopbits == '2':
            cmd.insert(-1, '-y')
            cmd.insert(-1, '2')

        return cmd

    def connect(self):
        """Connect to the serial port using embedded terminal"""
        # Check if debug mode is enabled
        if self.debug_checkbox.isChecked():
            self.status_label.setText("Opening debug terminal...")
            self.status_label.setStyleSheet("color: #fab387; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #fab387; font-size: 14px;")
            QApplication.processEvents()

            # Create and show terminal dialog in debug mode
            self.terminal_dialog = TerminalDialog(self, self.config)
            self.terminal_dialog.start_debug_mode()
            self.status_label.setText("Debug Mode - Terminal opened")
            self.status_label.setStyleSheet("color: #a6e3a1; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #a6e3a1; font-size: 14px;")
            self.terminal_dialog.exec()

            # Reset status after terminal closes
            self.status_label.setText("Ready to connect")
            self.status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #4caf50; font-size: 14px;")
            return

        # Check if picocom is installed
        try:
            subprocess.run(['which', 'picocom'], check=True, capture_output=True)
        except subprocess.CalledProcessError:
            QMessageBox.critical(
                self,
                "Error",
                "picocom is not installed.\n\n"
                "Install with:\nsudo pacman -S picocom"
            )
            return

        # Build command
        cmd = self.build_picocom_command()

        if not cmd:
            QMessageBox.warning(
                self,
                "Warning",
                "Select a valid serial port"
            )
            return

        self.status_label.setText("Opening terminal...")
        self.status_label.setStyleSheet("color: #fab387; font-size: 10pt;")
        self.status_led.setStyleSheet("color: #fab387; font-size: 14px;")
        QApplication.processEvents()

        # Create and show terminal dialog
        self.terminal_dialog = TerminalDialog(self, self.config)

        # Start picocom
        if self.terminal_dialog.start_picocom(cmd):
            self.status_label.setText("Connected - Terminal opened")
            self.status_label.setStyleSheet("color: #a6e3a1; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #a6e3a1; font-size: 14px;")
            self.terminal_dialog.exec()

            # Reset status after terminal closes
            self.status_label.setText("Ready to connect")
            self.status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #4caf50; font-size: 14px;")
        else:
            self.status_label.setText("Connection error")
            self.status_label.setStyleSheet("color: #f38ba8; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #f38ba8; font-size: 14px;")


def main():
    app = QApplication(sys.argv)

    # Set default font
    font = QFont("Sans Serif", 9)
    app.setFont(font)

    window = SerialTerminalGUI()
    window.show()

    sys.exit(app.exec())


if __name__ == '__main__':
    main()
