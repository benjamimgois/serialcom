#!/usr/bin/env python3
"""
SerialCom - Graphical interface for serial communication via picocom
Version: 1.1
"""

import sys
import os
import subprocess
import glob
import json
import socket
import threading
import socketserver
import telnetlib
from pathlib import Path

# Application version
VERSION = "1.1"


class TFTPHandler(socketserver.BaseRequestHandler):
    """Simple TFTP request handler supporting RRQ (read) operations"""

    TFTP_OPCODES = {
        1: 'RRQ',   # Read request
        2: 'WRQ',   # Write request
        3: 'DATA',  # Data
        4: 'ACK',   # Acknowledgment
        5: 'ERROR'  # Error
    }

    def handle(self):
        data, sock = self.request
        opcode = int.from_bytes(data[0:2], 'big')

        if opcode == 1:  # RRQ - Read Request
            self.handle_rrq(data, sock)
        elif opcode == 2:  # WRQ - Write Request
            self.handle_wrq(data, sock)

    def handle_rrq(self, data, sock):
        """Handle read request - send file to client"""
        # Parse filename from request
        parts = data[2:].split(b'\x00')
        filename = parts[0].decode('utf-8')

        # Get the file path from server's root directory
        filepath = os.path.join(self.server.tftp_root, filename)

        if not os.path.exists(filepath):
            # Send error: File not found
            error_packet = b'\x00\x05\x00\x01File not found\x00'
            sock.sendto(error_packet, self.client_address)
            print(f"[TFTP] File not found: {filename}")
            return

        try:
            with open(filepath, 'rb') as f:
                block_num = 1
                while True:
                    file_data = f.read(512)
                    # Build DATA packet: opcode (2 bytes) + block# (2 bytes) + data
                    data_packet = b'\x00\x03' + block_num.to_bytes(2, 'big') + file_data
                    sock.sendto(data_packet, self.client_address)

                    # Wait for ACK
                    sock.settimeout(5.0)
                    try:
                        ack_data, _ = sock.recvfrom(516)
                        ack_opcode = int.from_bytes(ack_data[0:2], 'big')
                        ack_block = int.from_bytes(ack_data[2:4], 'big')

                        if ack_opcode != 4 or ack_block != block_num:
                            print(f"[TFTP] Unexpected ACK: opcode={ack_opcode}, block={ack_block}")
                            break
                    except socket.timeout:
                        print(f"[TFTP] Timeout waiting for ACK block {block_num}")
                        break

                    if len(file_data) < 512:
                        # Last block sent
                        print(f"[TFTP] Transfer complete: {filename}")
                        break

                    block_num += 1

        except Exception as e:
            error_packet = b'\x00\x05\x00\x00' + str(e).encode() + b'\x00'
            sock.sendto(error_packet, self.client_address)
            print(f"[TFTP] Error reading file: {e}")

    def handle_wrq(self, data, sock):
        """Handle write request - receive file from client"""
        # Parse filename from request
        parts = data[2:].split(b'\x00')
        filename = parts[0].decode('utf-8')

        # Get the file path in server's root directory
        filepath = os.path.join(self.server.tftp_root, filename)

        try:
            # Send ACK for block 0 to start transfer
            ack_packet = b'\x00\x04\x00\x00'
            sock.sendto(ack_packet, self.client_address)

            with open(filepath, 'wb') as f:
                block_num = 1
                while True:
                    sock.settimeout(5.0)
                    try:
                        data_packet, _ = sock.recvfrom(516)
                        opcode = int.from_bytes(data_packet[0:2], 'big')
                        recv_block = int.from_bytes(data_packet[2:4], 'big')

                        if opcode != 3 or recv_block != block_num:
                            print(f"[TFTP] Unexpected DATA: opcode={opcode}, block={recv_block}")
                            break

                        file_data = data_packet[4:]
                        f.write(file_data)

                        # Send ACK
                        ack_packet = b'\x00\x04' + block_num.to_bytes(2, 'big')
                        sock.sendto(ack_packet, self.client_address)

                        if len(file_data) < 512:
                            print(f"[TFTP] Receive complete: {filename}")
                            break

                        block_num += 1

                    except socket.timeout:
                        print(f"[TFTP] Timeout waiting for DATA block {block_num}")
                        break

        except Exception as e:
            error_packet = b'\x00\x05\x00\x00' + str(e).encode() + b'\x00'
            sock.sendto(error_packet, self.client_address)
            print(f"[TFTP] Error writing file: {e}")


class TFTPServer:
    """Simple TFTP Server"""

    def __init__(self, host='0.0.0.0', port=69, root_dir=None):
        self.host = host
        self.port = port
        # Use XDG HOME for Flatpak compatibility
        self.root_dir = root_dir or os.environ.get('HOME', str(Path.home()))
        self.server = None
        self.thread = None
        self.running = False

    def start(self):
        """Start the TFTP server in a background thread"""
        if self.running:
            return False

        try:
            self.server = socketserver.UDPServer((self.host, self.port), TFTPHandler)
            self.server.tftp_root = self.root_dir
            self.thread = threading.Thread(target=self._serve, daemon=True)
            self.thread.start()
            self.running = True
            print(f"[TFTP] Server started on {self.host}:{self.port}, root: {self.root_dir}")
            return True
        except PermissionError:
            print(f"[TFTP] Permission denied for port {self.port}. Try running with sudo or use port > 1024")
            return False
        except Exception as e:
            print(f"[TFTP] Failed to start server: {e}")
            return False

    def _serve(self):
        """Serve requests until stopped"""
        try:
            self.server.serve_forever()
        except Exception as e:
            print(f"[TFTP] Server error: {e}")
            self.running = False

    def stop(self):
        """Stop the TFTP server"""
        if not self.running:
            return

        self.running = False
        if self.server:
            try:
                self.server.shutdown()
                self.server.server_close()
            except Exception as e:
                print(f"[TFTP] Error stopping server: {e}")
            finally:
                self.server = None
        print("[TFTP] Server stopped")

    def is_running(self):
        return self.running


def run_tftp_server_standalone(host, port, directory):
    """Run TFTP server in standalone mode (for sudo execution)"""
    import signal

    server = TFTPServer(host=host, port=port, root_dir=directory)

    def signal_handler(signum, frame):
        print("\n[TFTP] Stopping server...")
        server.stop()
        sys.exit(0)

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    if server.start():
        print(f"[TFTP] Server running on {host}:{port}")
        print(f"[TFTP] Directory: {directory}")
        print("[TFTP] Press Ctrl+C to stop")
        # Keep running until signal
        while server.is_running():
            import time
            time.sleep(1)
    else:
        print("[TFTP] Failed to start server")
        sys.exit(1)


# Check for TFTP server mode early (before importing GUI libraries)
# This allows the TFTP server to run with sudo without requiring
# PyQt6 and pyte to be installed system-wide
if __name__ == '__main__' and len(sys.argv) >= 5 and sys.argv[1] == '--tftp-server':
    host = sys.argv[2]
    port = int(sys.argv[3])
    directory = sys.argv[4]
    run_tftp_server_standalone(host, port, directory)
    sys.exit(0)


# Import GUI libraries (only reached if not in TFTP server mode)
import pyte
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QComboBox, QPushButton, QGroupBox, QFormLayout, QMessageBox,
    QTextEdit, QPlainTextEdit, QDialog, QInputDialog, QLineEdit,
    QGraphicsDropShadowEffect, QCheckBox, QFileDialog,
    QStackedWidget, QRadioButton, QButtonGroup, QTableWidget,
    QTableWidgetItem, QHeaderView, QAbstractItemView
)
from PyQt6.QtCore import Qt, QProcess, pyqtSignal, QTimer
from PyQt6.QtGui import QFont, QTextCursor, QKeyEvent, QTextBlockFormat, QColor, QPixmap, QIcon, QTextOption

try:
    from PyQt6.QtSerialPort import QSerialPortInfo
    SERIAL_PORT_AVAILABLE = True
except ImportError:
    SERIAL_PORT_AVAILABLE = False

try:
    import paramiko
    SSH_AVAILABLE = True
except ImportError:
    SSH_AVAILABLE = False


def get_network_interfaces():
    """Get list of network interfaces with their IP addresses"""
    interfaces = []

    try:
        # Use ip command to get interface information
        result = subprocess.run(['ip', '-4', 'addr', 'show'], capture_output=True, text=True)

        current_iface = None
        for line in result.stdout.split('\n'):
            # Match interface line (e.g., "2: eth0: <BROADCAST...")
            if ': ' in line and not line.startswith(' '):
                parts = line.split(': ')
                if len(parts) >= 2:
                    current_iface = parts[1].split('@')[0]

            # Match inet line (e.g., "    inet 192.168.1.100/24...")
            elif 'inet ' in line and current_iface:
                parts = line.strip().split()
                if len(parts) >= 2:
                    ip_with_mask = parts[1]
                    ip = ip_with_mask.split('/')[0]
                    if ip != '127.0.0.1':  # Skip loopback
                        interfaces.append((current_iface, ip))
    except Exception as e:
        print(f"Error getting interfaces: {e}")

    return interfaces


class ConfigManager:
    """Manage application settings using XDG Base Directory specification"""

    def __init__(self):
        # Get XDG config directory (defaults to ~/.config)
        xdg_config_home = os.environ.get('XDG_CONFIG_HOME')
        if not xdg_config_home:
            xdg_config_home = os.path.join(Path.home(), '.config')

        # Create serialcom config directory
        self.config_dir = os.path.join(xdg_config_home, 'serialcom')
        os.makedirs(self.config_dir, exist_ok=True)

        # Config file path
        self.config_file = os.path.join(self.config_dir, 'settings.json')

        # Default settings
        self.defaults = {
            # Serial settings
            'port_type': 'USB',
            'baudrate': '9600',
            'databits': '8',
            'parity': 'None',
            'stopbits': '1',
            'flow': 'None',
            'vendor': 'Generic',
            # Connection mode
            'connection_mode': 'serial',
            # SSH settings
            'ssh_host': '',
            'ssh_port': '22',
            'ssh_username': '',
            'ssh_auth_method': 'password',
            'ssh_key_path': '',
            'ssh_profiles': '[]'
        }

        # Load settings
        self.settings = self.load()

    def load(self):
        """Load settings from file, return defaults if file doesn't exist"""
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    loaded = json.load(f)
                    # Merge with defaults (in case new settings were added)
                    return {**self.defaults, **loaded}
            except (json.JSONDecodeError, IOError) as e:
                print(f"Warning: Could not load settings: {e}")
                return self.defaults.copy()
        return self.defaults.copy()

    def save(self):
        """Save settings to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.settings, f, indent=4)
        except IOError as e:
            print(f"Warning: Could not save settings: {e}")

    def set(self, key, value):
        """Set a setting value and save"""
        self.settings[key] = value
        self.save()

    def get(self, key):
        """Get a setting value"""
        return self.settings.get(key, self.defaults.get(key))

    def get_ssh_profiles(self):
        """Get list of saved SSH connection profiles"""
        profiles_json = self.settings.get('ssh_profiles', '[]')
        try:
            return json.loads(profiles_json)
        except json.JSONDecodeError:
            return []

    def save_ssh_profile(self, name, host, port, username, auth_method, key_path='', protocol='SSH'):
        """Save an SSH connection profile"""
        profiles = self.get_ssh_profiles()
        # Update existing or add new
        for i, p in enumerate(profiles):
            if p.get('name') == name:
                profiles[i] = {
                    'name': name, 'host': host, 'port': port,
                    'username': username, 'auth_method': auth_method,
                    'key_path': key_path, 'protocol': protocol
                }
                break
        else:
            profiles.append({
                'name': name, 'host': host, 'port': port,
                'username': username, 'auth_method': auth_method,
                'key_path': key_path, 'protocol': protocol
            })
        self.set('ssh_profiles', json.dumps(profiles))

    def delete_ssh_profile(self, name):
        """Delete an SSH connection profile"""
        profiles = [p for p in self.get_ssh_profiles() if p.get('name') != name]
        self.set('ssh_profiles', json.dumps(profiles))


class TerminalWidget(QTextEdit):
    """Terminal widget using pyte for proper VT100/ANSI emulation"""

    send_input = pyqtSignal(str)

    def __init__(self, parent=None, columns=120, lines=40):
        super().__init__(parent)
        self.setReadOnly(True)  # Terminal handles all input
        self.font_size = 10  # Default font size
        self.vendor = "Generic"  # Default vendor for syntax highlighting
        self.setFont(QFont("Monospace", self.font_size))

        # Track mouse state for selection
        self.mouse_pressed = False

        # Configure line wrap mode to prevent weird selection behavior
        self.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap)

        # Set word wrap mode for better text selection
        self.setWordWrapMode(QTextOption.WrapMode.NoWrap)

        # Prevent Tab from being used for focus navigation
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.setTabChangesFocus(False)

        # Initialize pyte terminal emulator
        self.screen = pyte.Screen(columns, lines)
        self.stream = pyte.Stream(self.screen)

        # Refresh timer for rendering
        self.refresh_timer = QTimer()
        self.refresh_timer.timeout.connect(self.render_screen)
        self.refresh_timer.start(50)  # Refresh every 50ms

        # Apply terminal styling
        self.setStyleSheet("""
            QTextEdit {
                background-color: #0a0a0a;
                color: #e0e0e0;
                border: none;
                padding: 10px;
            }
        """)

    def event(self, event):
        """Intercept Tab key before focus handling"""
        if event.type() == event.Type.KeyPress:
            if event.key() == Qt.Key.Key_Tab:
                # Handle Tab directly here, don't let it propagate
                self.send_input.emit('\t')
                event.accept()
                return True
        return super().event(event)

    def mousePressEvent(self, event):
        """Track mouse press for selection"""
        self.mouse_pressed = True
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        """Track mouse release after selection"""
        self.mouse_pressed = False
        super().mouseReleaseEvent(event)

    def keyPressEvent(self, event: QKeyEvent):
        """Handle key press and send to picocom"""
        key = event.key()
        modifiers = event.modifiers()
        text = event.text()

        # Build key sequence to send
        sequence = ""

        # Handle Ctrl combinations
        if modifiers & Qt.KeyboardModifier.ControlModifier:
            if key == Qt.Key.Key_A:
                sequence = '\x01'
            elif key == Qt.Key.Key_C:
                sequence = '\x03'
            elif key == Qt.Key.Key_D:
                sequence = '\x04'
            elif key == Qt.Key.Key_H:
                sequence = '\x08'
            elif key == Qt.Key.Key_L:
                sequence = '\x0c'
            elif key == Qt.Key.Key_U:
                sequence = '\x15'
            elif key == Qt.Key.Key_X:
                sequence = '\x18'
            elif key == Qt.Key.Key_Z:
                sequence = '\x1a'

        # Handle special keys
        elif key == Qt.Key.Key_Return or key == Qt.Key.Key_Enter:
            sequence = '\r'
        elif key == Qt.Key.Key_Backspace:
            sequence = '\x7f'
        elif key == Qt.Key.Key_Tab:
            sequence = '\t'
        elif key == Qt.Key.Key_Up:
            sequence = '\x1b[A'
        elif key == Qt.Key.Key_Down:
            sequence = '\x1b[B'
        elif key == Qt.Key.Key_Right:
            sequence = '\x1b[C'
        elif key == Qt.Key.Key_Left:
            sequence = '\x1b[D'
        elif key == Qt.Key.Key_Home:
            sequence = '\x1b[H'
        elif key == Qt.Key.Key_End:
            sequence = '\x1b[F'
        elif key == Qt.Key.Key_Delete:
            sequence = '\x1b[3~'
        elif key == Qt.Key.Key_PageUp:
            sequence = '\x1b[5~'
        elif key == Qt.Key.Key_PageDown:
            sequence = '\x1b[6~'
        elif text:
            sequence = text

        # Send sequence to picocom/SSH
        if sequence:
            print(f"[DEBUG] Key pressed, sending: {repr(sequence)}")
            self.send_input.emit(sequence)

    def append_output(self, text):
        """Feed text to pyte terminal emulator"""
        self.stream.feed(text)

    def set_vendor(self, vendor):
        """Set the vendor for syntax highlighting"""
        self.vendor = vendor

    def get_vendor_keywords(self):
        """Get keywords specific to the selected vendor"""
        # Common keywords for all vendors
        common = ['vlan', 'ip', 'ipv6', 'address', 'shutdown', 'route', 'static',
                  'permit', 'deny', 'any', 'host', 'password', 'secret', 'description',
                  'protocol', 'snmp', 'community', 'version', 'dhcp', 'server', 'pool',
                  'gateway', 'dns', 'lease', 'ntp', 'authentication', 'key', 'logging']

        # Cisco IOS/IOS-XE specific
        cisco = common + [
            'interface', 'no', 'router', 'bgp', 'ospf', 'eigrp', 'rip', 'isis',
            'access-list', 'line', 'vty', 'console', 'enable', 'service', 'hostname',
            'banner', 'switchport', 'mode', 'trunk', 'access', 'native', 'allowed',
            'spanning-tree', 'portfast', 'bpduguard', 'channel-group', 'lacp', 'pagp',
            'ssh', 'telnet', 'http', 'https', 'aaa', 'radius', 'tacacs',
            'port-security', 'maximum', 'violation', 'sticky', 'aging', 'time',
            'show', 'running-config', 'startup-config', 'brief', 'status', 'summary',
            'detail', 'controllers', 'inventory', 'copy', 'write', 'erase', 'reload',
            'configure', 'terminal', 'end', 'exit', 'crypto', 'isakmp', 'ipsec'
        ]

        # Huawei VRP specific
        huawei = common + [
            'display', 'system-view', 'quit', 'return', 'save', 'undo', 'sysname',
            'interface', 'user-interface', 'authentication-mode', 'aaa', 'local-user',
            'privilege', 'level', 'acl', 'rule', 'source', 'destination', 'basic',
            'advanced', 'mac-address', 'port-isolate', 'eth-trunk', 'mode', 'lacp',
            'stp', 'bpdu', 'edged-port', 'ssh', 'telnet', 'client', 'server',
            'cipher', 'hmac', 'exchange', 'dh-exchange', 'header', 'dot1x', 'vlan',
            'batch', 'port', 'hybrid', 'trunk', 'access', 'voice-vlan', 'qinq',
            'current-configuration', 'saved-configuration', 'startup', 'next'
        ]

        # H3C Comware specific
        h3c = common + [
            'display', 'system-view', 'quit', 'return', 'save', 'undo', 'sysname',
            'interface', 'user-interface', 'authentication-mode', 'local-user',
            'authorization-mode', 'accounting-mode', 'acl', 'rule', 'basic', 'advanced',
            'link-aggregation', 'lacp', 'stp', 'bpdu-protection', 'edge-port',
            'ssh', 'telnet', 'server', 'port-security', 'mac-address', 'port',
            'hybrid', 'trunk', 'access', 'voice', 'current-configuration', 'lldp'
        ]

        # Juniper Junos specific
        juniper = common + [
            'set', 'delete', 'show', 'commit', 'rollback', 'configure', 'edit',
            'top', 'up', 'interfaces', 'protocols', 'routing-options', 'firewall',
            'security', 'zones', 'policies', 'nat', 'chassis', 'system', 'services'
        ]

        # D-Link specific
        dlink = common + [
            'create', 'delete', 'config', 'show', 'enable', 'disable', 'vlan',
            'ports', 'stp', 'igmp', 'snmp', 'fdb', 'address_binding', 'vlanname',
            'link_aggregation', 'group', 'master', 'member', 'lacp', 'state',
            'traffic_control', 'broadcast', 'multicast', 'unicast', 'action',
            'access_profile', 'access_list', 'packet_content_mask', 'profile_id',
            'bpdu_tunnel', 'tunnel_mac', 'loopdetect', 'recover_timer', 'interval',
            'safeguard_engine', 'rising_threshold', 'falling_threshold', 'mode',
            'download', 'upload', 'save', 'reboot', 'reset', 'factory_default',
            'ip_source_guard', 'verify_source', 'trust', 'max_dynamic_hosts',
            'traffic_segmentation', 'forward_list', 'block', 'mirror', 'session',
            'source', 'destination', 'port_mirror', 'flow_mirror', 'cpu_filter'
        ]

        # Brocade Fabric OS specific
        brocade = common + [
            'switchshow', 'switchname', 'switchdisable', 'switchenable', 'configshow',
            'configupload', 'configdownload', 'configdefault', 'fabricshow',
            'portshow', 'portcfgshow', 'portdisable', 'portenable', 'portname',
            'portcfgpersistentdisable', 'portcfgpersistentenable', 'switchportshow',
            'aliacreate', 'aliadd', 'aliremove', 'alidelete', 'alishow',
            'zonecreate', 'zoneadd', 'zoneremove', 'zonedelete', 'zoneshow',
            'cfgcreate', 'cfgadd', 'cfgremove', 'cfgdelete', 'cfgshow', 'cfgenable',
            'cfgdisable', 'cfgsave', 'cfgclear', 'defzone', 'nozoning',
            'firmwareshow', 'firmwaredownload', 'firmwaredownloadstatus', 'version',
            'licenseshow', 'licenseadd', 'licenseremove', 'licenseport',
            'ipaddrset', 'ipaddrshow', 'nsshow', 'nsallshow', 'nscamshow',
            'reboot', 'fastboot', 'hashow', 'failover', 'setcontext',
            'tsclockserver', 'tstimezone', 'date', 'uptime', 'diagshow', 'supportshow'
        ]

        # Datacom specific (Brazilian manufacturer)
        datacom = common + [
            'show', 'configure', 'interface', 'vlan', 'no', 'router', 'bgp', 'ospf',
            'eigrp', 'rip', 'access-list', 'line', 'vty', 'console', 'enable',
            'service', 'hostname', 'banner', 'switchport', 'mode', 'trunk', 'access',
            'spanning-tree', 'portfast', 'port-channel', 'lacp', 'etherchannel',
            'ssh', 'telnet', 'http', 'snmp-server', 'ntp', 'clock', 'timezone',
            'aaa', 'radius', 'tacacs', 'local-user', 'privilege', 'level',
            'qos', 'class-map', 'policy-map', 'service-policy', 'trust', 'dscp',
            'write', 'memory', 'reload', 'copy', 'running-config', 'startup-config',
            'erase', 'boot', 'system', 'flash', 'tftp', 'ftp', 'upload', 'download',
            'mac', 'mac-address-table', 'aging-time', 'storm-control', 'broadcast',
            'errdisable', 'recovery', 'cause', 'interval', 'speed', 'duplex', 'mtu',
            'description', 'default-gateway', 'ip-address', 'subnet-mask', 'vrf'
        ]

        # Fortinet FortiOS specific (Firewall)
        fortinet = common + [
            'config', 'end', 'next', 'edit', 'delete', 'show', 'get', 'set', 'unset',
            'execute', 'diagnose', 'purge', 'rename', 'clone', 'append', 'clear',
            'system', 'global', 'interface', 'admin', 'settings', 'ha', 'dns',
            'firewall', 'policy', 'address', 'addrgrp', 'service', 'custom',
            'schedule', 'recurring', 'onetime', 'ippool', 'vip', 'central-snat',
            'router', 'static', 'bgp', 'ospf', 'rip', 'multicast', 'policy-route',
            'vpn', 'ipsec', 'phase1-interface', 'phase2-interface', 'ssl',
            'ssl-web-portal', 'tunnel-mode', 'web-mode', 'certificate', 'local',
            'user', 'local', 'radius', 'ldap', 'group', 'peer', 'peergrp',
            'antivirus', 'profile', 'webfilter', 'ips', 'sensor', 'application',
            'list', 'control', 'emailfilter', 'dlp', 'filefilter', 'voip',
            'waf', 'profile', 'signature', 'protocol-options', 'ssh-filter',
            'log', 'fortianalyzer', 'forticloud', 'syslogd', 'memory', 'disk',
            'backup', 'restore', 'reboot', 'shutdown', 'factoryreset', 'revision',
            'debug', 'flow', 'trace', 'sniffer', 'packet', 'top', 'performance',
            'status', 'arp', 'session', 'route', 'neighbor', 'hardware', 'nic'
        ]

        # Generic - combination of all
        generic = list(set(common + cisco + huawei + h3c + dlink + brocade + datacom + fortinet))

        vendor_keywords = {
            'Generic': generic,
            'Cisco': cisco,
            'Huawei': huawei,
            'H3C': h3c,
            'Juniper': juniper,
            'D-Link': dlink,
            'Brocade': brocade,
            'Datacom': datacom,
            'Fortinet': fortinet
        }

        return vendor_keywords.get(self.vendor, generic)

    def insert_cursor_at_position(self, html_text, raw_text, cursor_pos):
        """Insert cursor highlight at specific position in HTML text"""
        import re

        # If cursor is beyond text length, add it at the end
        if cursor_pos >= len(raw_text):
            return html_text + '<span style="color: #0a0a0a; background-color: #e0e0e0;">█</span>'

        # Build a map of raw text positions to HTML positions
        # We need to find where in the HTML the cursor_pos character appears
        raw_idx = 0
        html_idx = 0
        in_tag = False

        while html_idx < len(html_text) and raw_idx < len(raw_text):
            if html_text[html_idx] == '<':
                in_tag = True
                html_idx += 1
            elif html_text[html_idx] == '>':
                in_tag = False
                html_idx += 1
            elif in_tag:
                html_idx += 1
            else:
                # Check for HTML entities
                if html_text[html_idx:html_idx+5] == '&amp;':
                    if raw_idx == cursor_pos:
                        # Insert cursor here
                        return (html_text[:html_idx] +
                               '<span style="color: #0a0a0a; background-color: #e0e0e0;">&amp;</span>' +
                               html_text[html_idx+5:])
                    raw_idx += 1
                    html_idx += 5
                elif html_text[html_idx:html_idx+4] == '&lt;':
                    if raw_idx == cursor_pos:
                        return (html_text[:html_idx] +
                               '<span style="color: #0a0a0a; background-color: #e0e0e0;">&lt;</span>' +
                               html_text[html_idx+4:])
                    raw_idx += 1
                    html_idx += 4
                elif html_text[html_idx:html_idx+4] == '&gt;':
                    if raw_idx == cursor_pos:
                        return (html_text[:html_idx] +
                               '<span style="color: #0a0a0a; background-color: #e0e0e0;">&gt;</span>' +
                               html_text[html_idx+4:])
                    raw_idx += 1
                    html_idx += 4
                else:
                    if raw_idx == cursor_pos:
                        # Insert cursor here
                        char = html_text[html_idx]
                        if char == ' ':
                            char = '&nbsp;'
                        return (html_text[:html_idx] +
                               f'<span style="color: #0a0a0a; background-color: #e0e0e0;">{char}</span>' +
                               html_text[html_idx+1:])
                    raw_idx += 1
                    html_idx += 1

        return html_text

    def apply_syntax_highlighting(self, text):
        """Apply syntax highlighting for network equipment commands"""
        import re

        # Don't highlight if text is empty or whitespace
        if not text.strip():
            return text

        # Escape HTML
        text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

        # Get keywords for selected vendor
        keywords = self.get_vendor_keywords()

        # Highlight keywords (cyan - vibrant)
        for keyword in keywords:
            # Match whole words only, case insensitive
            pattern = r'\b(' + re.escape(keyword) + r')\b'
            text = re.sub(pattern, r'<span style="color: #00ffff; font-weight: bold;">\1</span>', text, flags=re.IGNORECASE)

        # Highlight IP addresses (green - vibrant)
        ip_pattern = r'\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?:/\d{1,2})?)\b'
        text = re.sub(ip_pattern, r'<span style="color: #00ff00; font-weight: bold;">\1</span>', text)

        # Highlight MAC addresses (lime green - vibrant)
        mac_pattern = r'\b([0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}|[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2})\b'
        text = re.sub(mac_pattern, r'<span style="color: #00ff88; font-weight: bold;">\1</span>', text)

        # Highlight numbers (yellow - vibrant)
        # Avoid matching numbers already highlighted (in IP/MAC)
        number_pattern = r'(?<![\d\.])\b(\d+)\b(?![\d\.])'
        text = re.sub(number_pattern, r'<span style="color: #ffff00;">\1</span>', text)

        # Highlight prompts (magenta - vibrant) - patterns like [SWITCH]#, Router>, etc.
        prompt_pattern = r'^([\[\<]?[A-Za-z0-9_-]+[\]\>]?[#&gt;])'
        text = re.sub(prompt_pattern, r'<span style="color: #ff00ff; font-weight: bold;">\1</span>', text, flags=re.MULTILINE)

        return text

    def get_ansi_color(self, color, is_background=False):
        """Convert pyte color to HTML color code"""
        # ANSI color palette (standard 16 colors)
        ansi_colors = {
            'black': '#000000',
            'red': '#cd0000',
            'green': '#00cd00',
            'brown': '#cdcd00',
            'blue': '#0000ee',
            'magenta': '#cd00cd',
            'cyan': '#00cdcd',
            'white': '#e5e5e5',
            # Bright variants
            'brightblack': '#7f7f7f',
            'brightred': '#ff0000',
            'brightgreen': '#00ff00',
            'brightyellow': '#ffff00',
            'brightblue': '#5c5cff',
            'brightmagenta': '#ff00ff',
            'brightcyan': '#00ffff',
            'brightwhite': '#ffffff',
        }

        # Default colors
        default_fg = '#e0e0e0'
        default_bg = 'transparent'

        if color == 'default':
            return default_bg if is_background else default_fg

        # Named color
        if isinstance(color, str):
            return ansi_colors.get(color, default_bg if is_background else default_fg)

        # 256-color palette (simplified - using approximations)
        if isinstance(color, int):
            if color < 16:
                # Standard colors
                color_names = ['black', 'red', 'green', 'brown', 'blue', 'magenta', 'cyan', 'white',
                              'brightblack', 'brightred', 'brightgreen', 'brightyellow',
                              'brightblue', 'brightmagenta', 'brightcyan', 'brightwhite']
                return ansi_colors.get(color_names[color], default_bg if is_background else default_fg)
            elif color < 232:
                # 216 color cube (6x6x6)
                color -= 16
                r = (color // 36) * 51
                g = ((color % 36) // 6) * 51
                b = (color % 6) * 51
                return f'#{r:02x}{g:02x}{b:02x}'
            else:
                # Grayscale
                gray = 8 + (color - 232) * 10
                return f'#{gray:02x}{gray:02x}{gray:02x}'

        return default_bg if is_background else default_fg

    def render_screen(self):
        """Render pyte screen buffer to QTextEdit with ANSI color support and syntax highlighting"""
        # Don't update if user is selecting text or mouse is pressed
        if self.textCursor().hasSelection() or self.mouse_pressed:
            return

        # Get cursor position from pyte
        cursor_x = self.screen.cursor.x
        cursor_y = self.screen.cursor.y

        # Build HTML content with cursor highlighting, ANSI colors, and syntax highlighting
        html_parts = []
        html_parts.append('<pre style="margin: 0; padding: 0; line-height: 1.2; user-select: text; -webkit-user-select: text;">')

        line_contents = []

        for y in range(self.screen.lines):
            # First, extract the raw text from this line
            raw_line = ""
            has_ansi_colors = False

            for x in range(self.screen.columns):
                char = self.screen.buffer[y][x]
                raw_line += char.data

                # Check if line has any ANSI colors/formatting
                if char.fg != 'default' or char.bg != 'default' or char.bold or char.italics or char.underscore or char.reverse:
                    has_ansi_colors = True

            # If line has ANSI colors, preserve them; otherwise apply syntax highlighting
            if has_ansi_colors:
                # Render with ANSI colors - group consecutive chars with same style
                line = ""
                x = 0
                while x < self.screen.columns:
                    char = self.screen.buffer[y][x]

                    # Get style for this character
                    fg_color = self.get_ansi_color(char.fg, is_background=False)
                    bg_color = self.get_ansi_color(char.bg, is_background=True)

                    # Build style string
                    styles = [f'color: {fg_color}']
                    if bg_color != 'transparent':
                        styles.append(f'background-color: {bg_color}')
                    if char.bold:
                        styles.append('font-weight: bold')
                    if char.italics:
                        styles.append('font-style: italic')
                    if char.underscore:
                        styles.append('text-decoration: underline')
                    if char.reverse:
                        styles = [f'color: {bg_color if bg_color != "transparent" else "#0a0a0a"}',
                                 f'background-color: {fg_color}']

                    # Check if this is cursor position
                    is_cursor = (y == cursor_y and x == cursor_x)

                    if is_cursor:
                        char_data = char.data
                        if char_data == ' ' or char_data == '':
                            char_data = '█'
                            styles = ['color: #e0e0e0', 'background-color: transparent']
                        else:
                            char_data = char_data.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                            styles = ['color: #0a0a0a', 'background-color: #e0e0e0']
                        style_str = '; '.join(styles)
                        line += f'<span style="{style_str}">{char_data}</span>'
                        x += 1
                    else:
                        # Group consecutive characters with same style
                        style_str = '; '.join(styles)
                        group_text = ""
                        start_x = x

                        while x < self.screen.columns:
                            if y == cursor_y and x == cursor_x:
                                break

                            next_char = self.screen.buffer[y][x]
                            next_fg = self.get_ansi_color(next_char.fg, is_background=False)
                            next_bg = self.get_ansi_color(next_char.bg, is_background=True)

                            # Check if style matches
                            next_styles = [f'color: {next_fg}']
                            if next_bg != 'transparent':
                                next_styles.append(f'background-color: {next_bg}')
                            if next_char.bold:
                                next_styles.append('font-weight: bold')
                            if next_char.italics:
                                next_styles.append('font-style: italic')
                            if next_char.underscore:
                                next_styles.append('text-decoration: underline')
                            if next_char.reverse:
                                next_styles = [f'color: {next_bg if next_bg != "transparent" else "#0a0a0a"}',
                                             f'background-color: {next_fg}']

                            next_style_str = '; '.join(next_styles)

                            if next_style_str != style_str:
                                break

                            # Add character to group
                            char_text = next_char.data.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                            if char_text == ' ':
                                char_text = '&nbsp;'
                            group_text += char_text
                            x += 1

                        if group_text:
                            line += f'<span style="{style_str}">{group_text}</span>'
            else:
                # Apply syntax highlighting to lines without ANSI colors
                highlighted_line = self.apply_syntax_highlighting(raw_line)

                # Add cursor if on this line
                if y == cursor_y:
                    highlighted_line = self.insert_cursor_at_position(highlighted_line, raw_line, cursor_x)

                line = highlighted_line

            line_contents.append(line)

        # Join lines with newlines and wrap in <pre>
        # Each line becomes a separate text block, preventing cross-line selection issues
        html_parts.append('\n'.join(line_contents))
        html_parts.append('</pre>')
        new_html = ''.join(html_parts)

        # Save scroll position - use tolerance for "at bottom" detection
        scrollbar = self.verticalScrollBar()
        # Consider "at bottom" if within 10 pixels of maximum
        at_bottom = scrollbar.maximum() - scrollbar.value() <= 10

        # Update text with HTML
        self.setHtml(new_html)

        # Auto-scroll to bottom if user was at or near bottom
        if at_bottom:
            # Move cursor to end
            cursor = self.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            self.setTextCursor(cursor)
            # Ensure cursor is visible
            self.ensureCursorVisible()
            # Force scroll to maximum
            scrollbar.setValue(scrollbar.maximum())

    def increase_font_size(self):
        """Increase terminal font size"""
        if self.font_size < 24:  # Maximum font size limit
            self.font_size += 1
            self.setFont(QFont("Monospace", self.font_size))

    def decrease_font_size(self):
        """Decrease terminal font size"""
        if self.font_size > 6:  # Minimum font size limit
            self.font_size -= 1
            self.setFont(QFont("Monospace", self.font_size))


class TerminalDialog(QDialog):
    """Dialog window containing the embedded terminal"""

    # Signal for thread-safe terminal output
    ssh_output_received = pyqtSignal(str)

    def __init__(self, parent=None, config=None):
        super().__init__(parent)
        self.setWindowTitle("SerialCom Terminal")
        self.setMinimumSize(1200, 700)
        self.process = None
        self.sudo_process = None
        self.config = config
        # SSH-related attributes
        self.ssh_client = None
        self.ssh_channel = None
        self.ssh_read_thread = None
        self.ssh_running = False
        # Telnet-related attributes
        self.telnet_client = None
        self.telnet_read_thread = None
        self.telnet_running = False
        self.connection_type = 'serial'

        self.init_ui()

        # Connect SSH output signal to terminal
        self.ssh_output_received.connect(self._on_ssh_output)

    def get_icon_path(self, icon_name, subdir='icons'):
        """Get the path to an icon for different installation types"""
        # Check for Flatpak
        flatpak_path = f'/app/share/io.github.benjamimgois.serialcom/{subdir}/{icon_name}'
        if os.path.exists(flatpak_path):
            return flatpak_path
        # Check for AppImage
        if os.environ.get('APPDIR'):
            appdir = os.environ.get('APPDIR')
            appimage_path = os.path.join(appdir, f'usr/share/serialcom/{subdir}/{icon_name}')
            if os.path.exists(appimage_path):
                return appimage_path
        # Local installation or development
        # Try assets/subdir directory
        assets_path = os.path.join(os.path.dirname(__file__), f'assets/{subdir}/{icon_name}')
        if os.path.exists(assets_path):
            return assets_path
        # Try root directory (legacy)
        root_path = os.path.join(os.path.dirname(__file__), icon_name)
        if os.path.exists(root_path):
            return root_path
        return None

    def get_arrow_icon_path(self):
        """Get the path to arrow_down.svg"""
        return self.get_icon_path('arrow_down.svg') or ''

    def get_vendor_icon_path(self, vendor):
        """Get the path to vendor icon SVG"""
        vendor_file = vendor.lower().replace('-', '').replace(' ', '') + '.svg'
        path = self.get_icon_path(vendor_file, 'vendors')
        if path:
            return path
        # Fallback to generic
        return self.get_icon_path('generic.svg', 'vendors') or ''

    def init_ui(self):
        """Initialize the terminal dialog UI"""
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Terminal widget
        self.terminal = TerminalWidget()
        self.terminal.send_input.connect(self.send_to_process)
        layout.addWidget(self.terminal)
        
        # Control buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(10, 5, 10, 10)

        # Font size buttons
        self.font_decrease_btn = QPushButton("A-")
        self.font_decrease_btn.setMinimumHeight(35)
        self.font_decrease_btn.setMaximumWidth(50)
        self.font_decrease_btn.setFont(QFont("Sans Serif", 10, QFont.Weight.Bold))
        self.font_decrease_btn.clicked.connect(self.terminal.decrease_font_size)
        self.font_decrease_btn.setStyleSheet("""
            QPushButton {
                background-color: #89b4fa;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #74a0e8;
            }
            QPushButton:pressed {
                background-color: #5f8cd6;
            }
        """)

        self.font_increase_btn = QPushButton("A+")
        self.font_increase_btn.setMinimumHeight(35)
        self.font_increase_btn.setMaximumWidth(50)
        self.font_increase_btn.setFont(QFont("Sans Serif", 10, QFont.Weight.Bold))
        self.font_increase_btn.clicked.connect(self.terminal.increase_font_size)
        self.font_increase_btn.setStyleSheet("""
            QPushButton {
                background-color: #89b4fa;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #74a0e8;
            }
            QPushButton:pressed {
                background-color: #5f8cd6;
            }
        """)

        self.disconnect_btn = QPushButton("DISCONNECT")
        self.disconnect_btn.setMinimumHeight(35)
        self.disconnect_btn.setFont(QFont("Sans Serif", 10, QFont.Weight.Bold))
        self.disconnect_btn.clicked.connect(self.disconnect)
        self.disconnect_btn.setStyleSheet("""
            QPushButton {
                background-color: #f38ba8;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #f26d8f;
            }
            QPushButton:pressed {
                background-color: #d95a7a;
            }
        """)

        # Vendor selector
        vendor_label = QLabel("Equipment:")
        vendor_label.setStyleSheet("""
            QLabel {
                color: #b0b0b0;
                font-size: 10pt;
                padding: 0 8px;
            }
        """)

        # Get arrow icon path (same method as main window)
        arrow_path = self.get_arrow_icon_path()

        self.vendor_combo = QComboBox()
        self.vendor_combo.addItems(['Generic', 'Cisco', 'Huawei', 'H3C', 'Juniper', 'D-Link', 'Brocade', 'Datacom', 'Fortinet'])

        # Load saved vendor selection
        if self.config:
            saved_vendor = self.config.get('vendor')
            index = self.vendor_combo.findText(saved_vendor)
            if index >= 0:
                self.vendor_combo.setCurrentIndex(index)
        else:
            self.vendor_combo.setCurrentText('Generic')

        self.vendor_combo.currentTextChanged.connect(self.change_vendor)
        self.vendor_combo.setMinimumHeight(35)
        self.vendor_combo.setMaximumWidth(130)
        self.vendor_combo.setStyleSheet(f"""
            QComboBox {{
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 2px solid #5a5a5a;
                border-radius: 6px;
                padding: 5px 28px 5px 10px;
                font-size: 10pt;
            }}
            QComboBox:hover {{
                border: 2px solid #707070;
                background-color: #454545;
            }}
            QComboBox:focus {{
                border: 2px solid #707070;
            }}
            QComboBox::drop-down {{
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 25px;
                border-left: 1px solid #5a5a5a;
                border-top-right-radius: 5px;
                border-bottom-right-radius: 5px;
                background-color: transparent;
            }}
            QComboBox::down-arrow {{
                image: url({arrow_path});
                width: 12px;
                height: 12px;
            }}
            QComboBox QAbstractItemView {{
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 2px solid #5a5a5a;
                selection-background-color: #5a5a5a;
                selection-color: #ffffff;
                outline: none;
                padding: 4px;
            }}
            QComboBox QAbstractItemView::item {{
                min-height: 28px;
                padding: 5px;
            }}
            QComboBox QAbstractItemView::item:hover {{
                background-color: #4a4a4a;
            }}
        """)

        # Vendor icon label
        self.vendor_icon = QLabel()
        self.vendor_icon.setFixedSize(36, 36)
        self.vendor_icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.vendor_icon.setToolTip("Equipment vendor")
        # Load initial vendor icon
        initial_vendor = self.vendor_combo.currentText()
        self.update_vendor_icon(initial_vendor)

        button_layout.addWidget(self.font_decrease_btn)
        button_layout.addSpacing(10)  # Add space between font buttons
        button_layout.addWidget(self.font_increase_btn)
        button_layout.addSpacing(20)  # Add space before vendor selector
        button_layout.addWidget(vendor_label)
        button_layout.addWidget(self.vendor_combo)
        button_layout.addSpacing(8)
        button_layout.addWidget(self.vendor_icon)
        button_layout.addStretch()
        button_layout.addWidget(self.disconnect_btn)

        layout.addLayout(button_layout)
        self.setLayout(layout)

    def update_vendor_icon(self, vendor):
        """Update the vendor icon QLabel with the appropriate SVG"""
        icon_path = self.get_vendor_icon_path(vendor)
        pixmap = QPixmap(icon_path)
        if not pixmap.isNull():
            # Scale pixmap to fit the label
            scaled_pixmap = pixmap.scaled(32, 32, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
            self.vendor_icon.setPixmap(scaled_pixmap)
        else:
            # Fallback to generic icon if loading fails
            fallback_path = self.get_vendor_icon_path('Generic')
            fallback_pixmap = QPixmap(fallback_path)
            if not fallback_pixmap.isNull():
                scaled_pixmap = fallback_pixmap.scaled(32, 32, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                self.vendor_icon.setPixmap(scaled_pixmap)

    def change_vendor(self, vendor):
        """Change the syntax highlighting vendor"""
        self.terminal.set_vendor(vendor)

        # Update vendor icon based on selection
        self.update_vendor_icon(vendor)

        # Save vendor selection
        if self.config:
            self.config.set('vendor', vendor)

    def start_picocom(self, cmd):
        """Start picocom process with sudo"""
        # Ask for sudo password using graphical dialog
        password, ok = QInputDialog.getText(
            self,
            "Sudo Password Required",
            "Please enter your sudo password to access serial port:",
            QLineEdit.EchoMode.Password
        )

        if not ok or not password:
            self.terminal.append_output("[CANCELLED] Password not provided\n")
            return False

        # Create the process
        self.process = QProcess(self)
        self.process.readyReadStandardOutput.connect(self.handle_stdout)
        self.process.readyReadStandardError.connect(self.handle_stderr)
        self.process.finished.connect(self.process_finished)

        # Build sudo command
        picocom_cmd = ' '.join(cmd)
        full_cmd = ['sudo', '-S'] + cmd

        # Start process
        self.terminal.append_output(f"Starting: {picocom_cmd}\n")

        self.process.start(full_cmd[0], full_cmd[1:])

        if not self.process.waitForStarted(3000):
            self.terminal.append_output("\n[ERROR] Failed to start picocom\n")
            return False

        # Send password to sudo
        self.process.write((password + '\n').encode())
        password = None  # Clear password from memory

        self.terminal.append_output("Connecting...\n\n")

        return True

    def start_debug_mode(self):
        """Start terminal in debug mode with simulated Cisco router output"""
        self.setWindowTitle("SerialCom Terminal [DEBUG MODE]")

        # Simulated Cisco router configuration
        cisco_output = """\r
\r
Router>\x1b[33menable\x1b[0m\r
Password: \r
Router#\x1b[33mshow running-config\x1b[0m\r
Building configuration...\r
\r
Current configuration : 1584 bytes\r
!\r
! Last configuration change at 14:32:15 UTC Mon Jan 15 2024\r
!\r
version 15.1\r
service timestamps debug datetime msec\r
service timestamps log datetime msec\r
no service password-encryption\r
!\r
hostname \x1b[36mRouter\x1b[0m\r
!\r
boot-start-marker\r
boot-end-marker\r
!\r
enable secret 5 $1$mERr$hx5rVt7rPNoS4wqbXKX7m0\r
!\r
no aaa new-model\r
!\r
interface \x1b[36mGigabitEthernet0/0\x1b[0m\r
 description \x1b[32mWAN Connection to ISP\x1b[0m\r
 ip address \x1b[33m203.0.113.1\x1b[0m \x1b[33m255.255.255.252\x1b[0m\r
 duplex auto\r
 speed auto\r
!\r
interface \x1b[36mGigabitEthernet0/1\x1b[0m\r
 description \x1b[32mLAN Network\x1b[0m\r
 ip address \x1b[33m192.168.1.1\x1b[0m \x1b[33m255.255.255.0\x1b[0m\r
 duplex auto\r
 speed auto\r
!\r
interface \x1b[36mGigabitEthernet0/2\x1b[0m\r
 description \x1b[32mDMZ Network\x1b[0m\r
 ip address \x1b[33m10.0.0.1\x1b[0m \x1b[33m255.255.255.0\x1b[0m\r
 duplex auto\r
 speed auto\r
!\r
ip route \x1b[33m0.0.0.0\x1b[0m \x1b[33m0.0.0.0\x1b[0m \x1b[33m203.0.113.2\x1b[0m\r
!\r
ip access-list extended \x1b[36mINBOUND_ACL\x1b[0m\r
 \x1b[32mpermit\x1b[0m tcp any any eq \x1b[33m22\x1b[0m\r
 \x1b[32mpermit\x1b[0m tcp any any eq \x1b[33m80\x1b[0m\r
 \x1b[32mpermit\x1b[0m tcp any any eq \x1b[33m443\x1b[0m\r
 \x1b[31mdeny\x1b[0m ip any any log\r
!\r
line con 0\r
 logging synchronous\r
line aux 0\r
line vty 0 4\r
 login local\r
 transport input ssh\r
!\r
end\r
\r
Router#\x1b[33mshow ip interface brief\x1b[0m\r
Interface              IP-Address      OK? Method Status                Protocol\r
GigabitEthernet0/0     \x1b[33m203.0.113.1\x1b[0m     YES NVRAM  \x1b[32mup\x1b[0m                    \x1b[32mup\x1b[0m\r
GigabitEthernet0/1     \x1b[33m192.168.1.1\x1b[0m     YES NVRAM  \x1b[32mup\x1b[0m                    \x1b[32mup\x1b[0m\r
GigabitEthernet0/2     \x1b[33m10.0.0.1\x1b[0m        YES NVRAM  \x1b[32mup\x1b[0m                    \x1b[32mup\x1b[0m\r
\r
Router#\x1b[33mshow version\x1b[0m\r
Cisco IOS Software, C2900 Software (C2900-UNIVERSALK9-M), Version 15.1(4)M4\r
Technical Support: http://www.cisco.com/techsupport\r
Copyright (c) 1986-2012 by Cisco Systems, Inc.\r
\r
ROM: System Bootstrap, Version 15.0(1r)M9\r
\r
Router uptime is \x1b[33m2 days, 14 hours, 32 minutes\x1b[0m\r
System returned to ROM by power-on\r
System image file is "flash:c2900-universalk9-mz.SPA.151-4.M4.bin"\r
\r
Cisco CISCO2911/K9 (revision 1.0) with \x1b[33m512000K/62464K\x1b[0m bytes of memory.\r
Processor board ID FTX1524A0WZ\r
3 Gigabit Ethernet interfaces\r
DRAM configuration is 64 bits wide with parity disabled.\r
256K bytes of non-volatile configuration memory.\r
\r
Router#_\r
"""

        # Feed the simulated output to the terminal
        self.terminal.append_output(cisco_output)

    def send_to_process(self, text):
        """Send input to the active connection (picocom, SSH, or Telnet)"""
        if self.connection_type == 'ssh':
            self.send_to_ssh(text)
        elif self.connection_type == 'telnet':
            self.send_to_telnet(text)
        elif self.process and self.process.state() == QProcess.ProcessState.Running:
            self.process.write(text.encode())

    def start_ssh(self, host, port, username, password=None, key_path=None):
        """Start SSH connection using paramiko"""
        if not SSH_AVAILABLE:
            self.terminal.append_output("[ERROR] paramiko library not installed\n")
            self.terminal.append_output("Install with: pip install paramiko\n")
            return False

        self.connection_type = 'ssh'
        self.setWindowTitle(f"SerialCom Terminal - SSH: {username}@{host}")

        try:
            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            self.terminal.append_output(f"Connecting to {host}:{port}...\n")

            if key_path:
                # Key-based authentication
                key = paramiko.RSAKey.from_private_key_file(key_path)
                self.ssh_client.connect(host, port=int(port), username=username, pkey=key)
            else:
                # Password authentication
                self.ssh_client.connect(host, port=int(port), username=username, password=password)

            # Request a pseudo-terminal
            self.ssh_channel = self.ssh_client.invoke_shell(term='xterm-256color', width=120, height=40)
            self.ssh_channel.settimeout(0.1)
            self.ssh_running = True

            # Start read thread
            self.ssh_read_thread = threading.Thread(target=self._ssh_read_loop, daemon=True)
            self.ssh_read_thread.start()

            self.terminal.append_output(f"Connected to {host}\n\n")
            # Ensure terminal has focus for keyboard input
            self.terminal.setFocus()
            return True

        except paramiko.AuthenticationException:
            self.terminal.append_output("[ERROR] Authentication failed\n")
            return False
        except paramiko.SSHException as e:
            self.terminal.append_output(f"[ERROR] SSH error: {e}\n")
            return False
        except Exception as e:
            self.terminal.append_output(f"[ERROR] Connection failed: {e}\n")
            return False

    def _ssh_read_loop(self):
        """Background thread to read SSH output"""
        import time
        print("[DEBUG] SSH read thread started")
        while self.ssh_running and self.ssh_channel:
            try:
                if self.ssh_channel.recv_ready():
                    data = self.ssh_channel.recv(4096)
                    if data:
                        text = data.decode('utf-8', errors='replace')
                        print(f"[DEBUG] Received {len(data)} bytes")
                        # Use signal for thread-safe UI update
                        self.ssh_output_received.emit(text)
                else:
                    # Small sleep to prevent CPU spinning
                    time.sleep(0.05)
            except socket.timeout:
                continue
            except Exception as e:
                print(f"[DEBUG] SSH read error: {e}")
                if self.ssh_running:
                    self.ssh_output_received.emit(f"\n[SSH Error: {e}]\n")
                break
        print("[DEBUG] SSH read thread ended")

    def _on_ssh_output(self, text):
        """Slot to handle SSH output in main thread"""
        print(f"[DEBUG] _on_ssh_output called with {len(text)} chars")
        self.terminal.append_output(text)

    def send_to_ssh(self, text):
        """Send input to SSH channel"""
        if self.ssh_channel and self.ssh_running:
            try:
                print(f"[DEBUG] Sending: {repr(text)}")
                self.ssh_channel.send(text.encode('utf-8'))
            except Exception as e:
                print(f"[DEBUG] Send error: {e}")
                self.terminal.append_output(f"\n[Send error: {e}]\n")
        else:
            print(f"[DEBUG] Cannot send - channel: {self.ssh_channel}, running: {self.ssh_running}")

    def disconnect_ssh(self):
        """Disconnect SSH session"""
        self.ssh_running = False
        if self.ssh_channel:
            try:
                self.ssh_channel.close()
            except:
                pass
            self.ssh_channel = None
        if self.ssh_client:
            try:
                self.ssh_client.close()
            except:
                pass
            self.ssh_client = None

    def start_telnet(self, host, port, username=None):
        """Start Telnet connection"""
        self.connection_type = 'telnet'
        self.setWindowTitle(f"SerialCom Terminal - Telnet: {host}")

        try:
            self.terminal.append_output(f"Connecting to {host}:{port}...\n")
            self.telnet_client = telnetlib.Telnet(host, int(port), timeout=10)
            self.telnet_running = True

            # Start read thread
            self.telnet_read_thread = threading.Thread(target=self._telnet_read_loop, daemon=True)
            self.telnet_read_thread.start()

            self.terminal.append_output(f"Connected to {host}\n\n")
            # Ensure terminal has focus for keyboard input
            self.terminal.setFocus()
            return True

        except Exception as e:
            self.terminal.append_output(f"[ERROR] Connection failed: {e}\n")
            return False

    def _telnet_read_loop(self):
        """Background thread to read Telnet output"""
        import time
        print("[DEBUG] Telnet read thread started")
        while self.telnet_running and self.telnet_client:
            try:
                data = self.telnet_client.read_very_eager()
                if data:
                    text = data.decode('utf-8', errors='replace')
                    print(f"[DEBUG] Received {len(data)} bytes")
                    # Use signal for thread-safe UI update
                    self.ssh_output_received.emit(text)
                else:
                    # Small sleep to prevent CPU spinning
                    time.sleep(0.05)
            except EOFError:
                print("[DEBUG] Telnet connection closed")
                if self.telnet_running:
                    self.ssh_output_received.emit("\n[Connection closed by remote host]\n")
                break
            except Exception as e:
                print(f"[DEBUG] Telnet read error: {e}")
                if self.telnet_running:
                    self.ssh_output_received.emit(f"\n[Telnet Error: {e}]\n")
                break
        print("[DEBUG] Telnet read thread ended")

    def send_to_telnet(self, text):
        """Send input to Telnet connection"""
        if self.telnet_client and self.telnet_running:
            try:
                print(f"[DEBUG] Sending: {repr(text)}")
                self.telnet_client.write(text.encode('utf-8'))
            except Exception as e:
                print(f"[DEBUG] Send error: {e}")
                self.terminal.append_output(f"\n[Send error: {e}]\n")
        else:
            print(f"[DEBUG] Cannot send - client: {self.telnet_client}, running: {self.telnet_running}")

    def disconnect_telnet(self):
        """Disconnect Telnet session"""
        self.telnet_running = False
        if self.telnet_client:
            try:
                self.telnet_client.close()
            except:
                pass
            self.telnet_client = None
    
    def handle_stdout(self):
        """Handle standard output from picocom"""
        if self.process:
            data = self.process.readAllStandardOutput()
            text = bytes(data).decode('utf-8', errors='replace')
            self.terminal.append_output(text)
    
    def handle_stderr(self):
        """Handle standard error from picocom"""
        if self.process:
            data = self.process.readAllStandardError()
            text = bytes(data).decode('utf-8', errors='replace')
            self.terminal.append_output(text)
    
    def process_finished(self, exit_code, exit_status):
        """Handle process termination"""
        self.terminal.append_output(f"\n\n[Process terminated with exit code {exit_code}]\n")
        self.terminal.append_output("You can close this window.\n")
        self.disconnect_btn.setText("CLOSE")
    
    def disconnect(self):
        """Disconnect from serial port, SSH, or Telnet"""
        if self.connection_type == 'ssh':
            self.disconnect_ssh()
        elif self.connection_type == 'telnet':
            self.disconnect_telnet()
        elif self.process and self.process.state() == QProcess.ProcessState.Running:
            # Send Ctrl+A Ctrl+X to exit picocom gracefully
            self.process.write(b'\x01\x18')

            # Wait a bit for graceful exit
            if not self.process.waitForFinished(2000):
                # Force terminate if needed
                self.process.terminate()
                if not self.process.waitForFinished(1000):
                    self.process.kill()

        self.close()
    
    def closeEvent(self, event):
        """Handle window close event"""
        is_connected = False
        if self.connection_type == 'ssh':
            is_connected = self.ssh_running
        elif self.connection_type == 'telnet':
            is_connected = self.telnet_running
        elif self.process:
            is_connected = self.process.state() == QProcess.ProcessState.Running

        if is_connected:
            reply = QMessageBox.question(
                self,
                'Confirm Exit',
                'Connection is still active. Disconnect and close?',
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                self.disconnect()
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()


class SerialTerminalGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(f"SerialCom v{VERSION}")
        self.setFixedSize(600, 780)
        self.terminal_dialog = None
        self.tftp_process = None
        self.config = ConfigManager()
        self.init_ui()
        self.apply_styles()
        self.load_settings()

    def init_ui(self):
        """Initialize the user interface with vertical tabs"""
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main horizontal layout (tabs on left, content on right)
        main_h_layout = QHBoxLayout()
        main_h_layout.setSpacing(0)
        main_h_layout.setContentsMargins(0, 0, 0, 0)

        # === LEFT SIDE: Vertical Tab Bar ===
        self.tab_widget = QWidget()
        self.tab_widget.setFixedWidth(50)
        self.tab_widget.setStyleSheet("""
            QWidget {
                background-color: #37474f;
                border-right: 1px solid #263238;
            }
        """)

        tab_layout = QVBoxLayout()
        tab_layout.setContentsMargins(5, 10, 5, 10)
        tab_layout.setSpacing(10)

        # Serial tab button
        self.serial_tab_btn = QPushButton()
        self.serial_tab_btn.setFixedSize(40, 40)
        # Load custom serial port icon
        serial_icon_path = self.get_tab_icon_path('serial-port-white.svg')
        if serial_icon_path:
            self.serial_tab_btn.setIcon(QIcon(serial_icon_path))
            self.serial_tab_btn.setIconSize(self.serial_tab_btn.size() * 0.6)
        else:
            self.serial_tab_btn.setIcon(self.style().standardIcon(
                self.style().StandardPixmap.SP_DriveHDIcon))
        self.serial_tab_btn.setToolTip("Serial Connection")
        self.serial_tab_btn.setCheckable(True)
        self.serial_tab_btn.setChecked(True)
        self.serial_tab_btn.clicked.connect(lambda: self.switch_tab(0))

        # SSH tab button
        self.ssh_tab_btn = QPushButton()
        self.ssh_tab_btn.setFixedSize(40, 40)
        # Load custom SSH icon
        ssh_icon_path = self.get_tab_icon_path('ssh_icon.svg')
        if ssh_icon_path:
            self.ssh_tab_btn.setIcon(QIcon(ssh_icon_path))
            self.ssh_tab_btn.setIconSize(self.ssh_tab_btn.size() * 0.6)
        else:
            self.ssh_tab_btn.setIcon(self.style().standardIcon(
                self.style().StandardPixmap.SP_ComputerIcon))
        self.ssh_tab_btn.setToolTip("SSH Connection")
        self.ssh_tab_btn.setCheckable(True)
        self.ssh_tab_btn.clicked.connect(lambda: self.switch_tab(1))

        # Style for tab buttons
        tab_btn_style = """
            QPushButton {
                background-color: transparent;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #546e7a;
            }
            QPushButton:checked {
                background-color: #4caf50;
                border: none;
            }
        """
        self.serial_tab_btn.setStyleSheet(tab_btn_style)
        self.ssh_tab_btn.setStyleSheet(tab_btn_style)

        tab_layout.addWidget(self.serial_tab_btn)
        tab_layout.addWidget(self.ssh_tab_btn)
        tab_layout.addStretch()
        self.tab_widget.setLayout(tab_layout)

        # === RIGHT SIDE: Stacked Widget for Content ===
        self.content_stack = QStackedWidget()

        # Create Serial configuration page
        self.serial_page = self.create_serial_page()
        self.content_stack.addWidget(self.serial_page)

        # Create SSH configuration page
        self.ssh_page = self.create_ssh_page()
        self.content_stack.addWidget(self.ssh_page)

        # Add to main layout
        main_h_layout.addWidget(self.tab_widget)
        main_h_layout.addWidget(self.content_stack, 1)

        central_widget.setLayout(main_h_layout)

        # Update port list
        self.update_port_list()

    def switch_tab(self, index):
        """Switch between Serial and SSH tabs"""
        self.content_stack.setCurrentIndex(index)
        self.serial_tab_btn.setChecked(index == 0)
        self.ssh_tab_btn.setChecked(index == 1)
        self.config.set('connection_mode', 'serial' if index == 0 else 'ssh')

    def create_serial_page(self):
        """Create the serial connection configuration page"""
        page = QWidget()
        main_layout = QVBoxLayout()
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(20, 20, 20, 20)

        # Standard width for all comboboxes
        combo_width = 200

        # Port configuration group
        port_group = QGroupBox("Port Configuration")
        port_layout = QFormLayout()
        port_layout.setVerticalSpacing(15)
        port_layout.setContentsMargins(15, 15, 15, 15)
        port_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        port_layout.setFormAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Port type
        self.port_type = QComboBox()
        self.port_type.addItems(['USB', 'Serial'])
        self.port_type.setCurrentIndex(0)
        self.port_type.setFixedWidth(combo_width)
        self.port_type.setToolTip("Select the type of serial port")
        self.port_type.currentIndexChanged.connect(self.update_port_list)
        port_layout.addRow("Type:", self.port_type)

        # Port
        self.port = QComboBox()
        self.port.setFixedWidth(combo_width)
        self.port.setToolTip("Select the serial port to connect")
        port_layout.addRow("Port:", self.port)

        port_group.setLayout(port_layout)

        # Add shadow effect to port group
        shadow1 = QGraphicsDropShadowEffect()
        shadow1.setBlurRadius(15)
        shadow1.setXOffset(0)
        shadow1.setYOffset(2)
        shadow1.setColor(QColor(0, 0, 0, 30))
        port_group.setGraphicsEffect(shadow1)

        main_layout.addWidget(port_group)

        # Communication parameters group
        comm_group = QGroupBox("Communication Parameters")
        comm_layout = QFormLayout()
        comm_layout.setVerticalSpacing(15)
        comm_layout.setContentsMargins(15, 15, 15, 15)
        comm_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        comm_layout.setFormAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Baud Rate - MAIN FIELD (highlighted)
        velocity_label = QLabel("Baud Rate:")
        velocity_font = QFont("Sans Serif", 10, QFont.Weight.Bold)
        velocity_label.setFont(velocity_font)
        velocity_label.setStyleSheet("color: #2e7d32;")

        self.baudrate = QComboBox()
        self.baudrate.addItems([
            '300', '1200', '2400', '4800', '9600', '19200',
            '38400', '57600', '115200', '230400', '460800', '921600'
        ])
        self.baudrate.setCurrentText('9600')
        self.baudrate.setFixedWidth(combo_width)
        self.baudrate.setToolTip("Communication speed in bits per second")
        self.baudrate.setStyleSheet("""
            QComboBox {
                border: 2px solid #4caf50;
                background-color: #f1f8e9;
            }
            QComboBox:hover {
                border: 2px solid #2e7d32;
                background-color: #e8f5e9;
            }
        """)
        comm_layout.addRow(velocity_label, self.baudrate)

        # Data bits
        self.databits = QComboBox()
        self.databits.addItems(['5', '6', '7', '8'])
        self.databits.setCurrentText('8')
        self.databits.setFixedWidth(combo_width)
        self.databits.setToolTip("Number of data bits per character (usually 8)")
        comm_layout.addRow("Data Bits:", self.databits)

        # Parity
        self.parity = QComboBox()
        self.parity.addItems(['None', 'Even', 'Odd'])
        self.parity.setCurrentText('None')
        self.parity.setFixedWidth(combo_width)
        self.parity.setToolTip("Error detection method (usually None)")
        comm_layout.addRow("Parity:", self.parity)

        # Stop bits
        self.stopbits = QComboBox()
        self.stopbits.addItems(['1', '2'])
        self.stopbits.setCurrentText('1')
        self.stopbits.setFixedWidth(combo_width)
        self.stopbits.setToolTip("Number of stop bits (usually 1)")
        comm_layout.addRow("Stop Bits:", self.stopbits)

        # Flow control
        self.flow = QComboBox()
        self.flow.addItems(['None', 'Hardware (RTS/CTS)', 'Software (XON/XOFF)'])
        self.flow.setCurrentText('None')
        self.flow.setFixedWidth(combo_width)
        self.flow.setToolTip("Flow control method (usually None)")
        comm_layout.addRow("Flow Control:", self.flow)

        comm_group.setLayout(comm_layout)

        # Add shadow effect to comm group
        shadow2 = QGraphicsDropShadowEffect()
        shadow2.setBlurRadius(15)
        shadow2.setXOffset(0)
        shadow2.setYOffset(2)
        shadow2.setColor(QColor(0, 0, 0, 30))
        comm_group.setGraphicsEffect(shadow2)

        main_layout.addWidget(comm_group)

        # TFTP Server group
        tftp_group = QGroupBox("TFTP Server")
        tftp_layout = QFormLayout()
        tftp_layout.setVerticalSpacing(12)
        tftp_layout.setContentsMargins(15, 15, 15, 15)
        tftp_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        tftp_layout.setFormAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Network interface selector
        self.tftp_interface = QComboBox()
        self.tftp_interface.setFixedWidth(combo_width)
        self.tftp_interface.setToolTip("Select network interface for TFTP server")
        # Smaller font to fit longer IP addresses
        self.tftp_interface.setStyleSheet("""
            QComboBox {
                font-size: 8pt;
            }
        """)
        self.update_network_interfaces()
        tftp_layout.addRow("Interface:", self.tftp_interface)

        # TFTP directory with browse button and start button
        tftp_dir_layout = QHBoxLayout()
        tftp_dir_layout.setContentsMargins(0, 0, 0, 0)
        tftp_dir_layout.setSpacing(2)

        self.tftp_directory = QLineEdit()
        self.tftp_directory.setFixedWidth(combo_width)
        # Use XDG HOME for Flatpak compatibility
        default_tftp_dir = os.environ.get('HOME', str(Path.home()))
        self.tftp_directory.setText(default_tftp_dir)
        self.tftp_directory.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.tftp_directory.setToolTip("Directory containing firmware files")
        self.tftp_directory.setStyleSheet("""
            QLineEdit {
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                padding: 4px 10px;
                background-color: #f5f5f5;
                color: #333333;
                font-size: 10pt;
            }
        """)

        self.tftp_browse_btn = QPushButton()
        self.tftp_browse_btn.setFixedSize(28, 28)
        self.tftp_browse_btn.setIcon(self.style().standardIcon(self.style().StandardPixmap.SP_DirOpenIcon))
        self.tftp_browse_btn.setToolTip("Browse for directory")
        self.tftp_browse_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.tftp_browse_btn.setStyleSheet("""
            QPushButton {
                background-color: #e0e0e0;
                border: 1px solid #bdbdbd;
                border-radius: 6px;
            }
            QPushButton:hover {
                background-color: #d0d0d0;
                border: 1px solid #9e9e9e;
            }
            QPushButton:pressed {
                background-color: #bdbdbd;
            }
        """)
        self.tftp_browse_btn.clicked.connect(self.browse_tftp_directory)

        self.tftp_btn = QPushButton("Start TFTP")
        self.tftp_btn.setFixedHeight(28)
        self.tftp_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.tftp_btn.clicked.connect(self.toggle_tftp_server)
        self.tftp_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 4px 16px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)

        tftp_dir_layout.addWidget(self.tftp_directory)
        tftp_dir_layout.addWidget(self.tftp_browse_btn)
        tftp_dir_layout.addSpacing(8)
        tftp_dir_layout.addWidget(self.tftp_btn)
        tftp_dir_layout.addStretch()

        tftp_dir_widget = QWidget()
        tftp_dir_widget.setContentsMargins(0, 0, 0, 0)
        tftp_dir_widget.setLayout(tftp_dir_layout)
        tftp_layout.addRow("Directory:", tftp_dir_widget)

        tftp_group.setLayout(tftp_layout)

        # Add shadow effect to tftp group
        shadow3 = QGraphicsDropShadowEffect()
        shadow3.setBlurRadius(15)
        shadow3.setXOffset(0)
        shadow3.setYOffset(2)
        shadow3.setColor(QColor(0, 0, 0, 30))
        tftp_group.setGraphicsEffect(shadow3)

        main_layout.addWidget(tftp_group)

        # Initialize TFTP server instance
        self.tftp_server = None

        # Debug mode checkbox
        self.debug_checkbox = QCheckBox("Debug Mode (simulate Cisco router)")
        self.debug_checkbox.setToolTip("Enable to test terminal without a real device")
        self.debug_checkbox.setStyleSheet("color: #606060; font-size: 9pt;")
        main_layout.addWidget(self.debug_checkbox)

        # Connect button
        self.connect_btn = QPushButton("CONNECT")
        self.connect_btn.setMinimumHeight(45)
        self.connect_btn.setFont(QFont("Sans Serif", 11, QFont.Weight.Bold))
        self.connect_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        # Keep Connect button in original green color
        self.connect_btn.setStyleSheet("""
            QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 8px;
                padding: 12px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #43a047;
            }
            QPushButton:pressed {
                background-color: #388e3c;
            }
        """)
        self.connect_btn.clicked.connect(self.connect)
        main_layout.addWidget(self.connect_btn)

        # Status with LED indicator
        status_layout = QHBoxLayout()
        status_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        status_layout.setSpacing(8)

        self.status_led = QLabel("●")
        self.status_led.setStyleSheet("color: #4caf50; font-size: 14px;")

        self.status_label = QLabel("Ready to connect")
        self.status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")

        status_layout.addWidget(self.status_led)
        status_layout.addWidget(self.status_label)

        status_widget = QWidget()
        status_widget.setLayout(status_layout)
        main_layout.addWidget(status_widget)

        page.setLayout(main_layout)
        return page

    def create_ssh_page(self):
        """Create the SSH connection configuration page"""
        page = QWidget()
        main_layout = QVBoxLayout()
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(15, 15, 15, 15)

        combo_width = 200

        # Style for QLineEdit fields (compact)
        line_edit_style = """
            QLineEdit {
                border: 1px solid #d0d0d0;
                border-radius: 4px;
                padding: 2px 8px;
                background-color: #f5f5f5;
                color: #333333;
                font-size: 10pt;
            }
        """

        # === Remote Connection Group ===
        ssh_group = QGroupBox("Remote Connection")
        ssh_layout = QFormLayout()
        ssh_layout.setVerticalSpacing(8)
        ssh_layout.setContentsMargins(10, 10, 10, 10)
        ssh_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)

        # Protocol selection (SSH/Telnet)
        radio_style = "QRadioButton { color: #333333; font-size: 10pt; }"
        self.protocol_ssh_radio = QRadioButton("SSH")
        self.protocol_ssh_radio.setChecked(True)
        self.protocol_ssh_radio.setStyleSheet(radio_style)
        self.protocol_telnet_radio = QRadioButton("Telnet")
        self.protocol_telnet_radio.setStyleSheet(radio_style)

        self.protocol_button_group = QButtonGroup()
        self.protocol_button_group.addButton(self.protocol_ssh_radio, 0)
        self.protocol_button_group.addButton(self.protocol_telnet_radio, 1)
        self.protocol_button_group.buttonClicked.connect(self.toggle_protocol)

        protocol_widget = QWidget()
        protocol_layout = QHBoxLayout()
        protocol_layout.setContentsMargins(0, 0, 0, 0)
        protocol_layout.addWidget(self.protocol_ssh_radio)
        protocol_layout.addWidget(self.protocol_telnet_radio)
        protocol_layout.addStretch()
        protocol_widget.setLayout(protocol_layout)
        ssh_layout.addRow("Protocol:", protocol_widget)

        # Host
        self.ssh_host = QLineEdit()
        self.ssh_host.setFixedWidth(combo_width)
        self.ssh_host.setPlaceholderText("192.168.1.1 or hostname")
        self.ssh_host.setToolTip("SSH/Telnet server hostname or IP address")
        self.ssh_host.setStyleSheet(line_edit_style)
        ssh_layout.addRow("Host:", self.ssh_host)

        # Port
        self.ssh_port = QLineEdit()
        self.ssh_port.setFixedWidth(80)
        self.ssh_port.setText("22")
        self.ssh_port.setToolTip("SSH/Telnet port (default: 22 for SSH, 23 for Telnet)")
        self.ssh_port.setStyleSheet(line_edit_style)
        ssh_layout.addRow("Port:", self.ssh_port)

        # Username
        self.ssh_username = QLineEdit()
        self.ssh_username.setFixedWidth(combo_width)
        self.ssh_username.setPlaceholderText("admin")
        self.ssh_username.setToolTip("Username for authentication")
        self.ssh_username.setStyleSheet(line_edit_style)
        ssh_layout.addRow("Username:", self.ssh_username)

        # Password (for both SSH and Telnet)
        self.ssh_password = QLineEdit()
        self.ssh_password.setEchoMode(QLineEdit.EchoMode.Password)
        self.ssh_password.setFixedWidth(combo_width)
        self.ssh_password.setPlaceholderText("Leave blank to be prompted")
        self.ssh_password.setToolTip("Password for authentication (optional)")
        self.ssh_password.setStyleSheet(line_edit_style)
        ssh_layout.addRow("Password:", self.ssh_password)

        # SSH Key checkbox (for SSH only)
        self.use_ssh_key = QCheckBox("Use SSH Key instead of password")
        self.use_ssh_key.setStyleSheet("QCheckBox { color: #333333; font-size: 10pt; }")
        self.use_ssh_key.toggled.connect(self.toggle_ssh_key)
        ssh_layout.addRow("", self.use_ssh_key)

        # SSH Key file field (hidden by default)
        self.ssh_key_widget = QWidget()
        key_layout = QHBoxLayout()
        key_layout.setContentsMargins(0, 0, 0, 0)
        key_layout.setSpacing(5)

        self.ssh_key_path = QLineEdit()
        self.ssh_key_path.setFixedWidth(combo_width - 30)
        self.ssh_key_path.setPlaceholderText("~/.ssh/id_rsa")
        self.ssh_key_path.setStyleSheet(line_edit_style)

        self.ssh_key_browse = QPushButton()
        self.ssh_key_browse.setFixedSize(24, 24)
        self.ssh_key_browse.setIcon(self.style().standardIcon(
            self.style().StandardPixmap.SP_FileIcon))
        self.ssh_key_browse.setToolTip("Browse for SSH key file")
        self.ssh_key_browse.setCursor(Qt.CursorShape.PointingHandCursor)
        self.ssh_key_browse.setStyleSheet("""
            QPushButton {
                background-color: #e0e0e0;
                border: 1px solid #bdbdbd;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #d0d0d0;
                border: 1px solid #9e9e9e;
            }
        """)
        self.ssh_key_browse.clicked.connect(self.browse_ssh_key)

        key_layout.addWidget(self.ssh_key_path)
        key_layout.addWidget(self.ssh_key_browse)
        self.ssh_key_widget.setLayout(key_layout)
        self.ssh_key_widget.setVisible(False)
        ssh_layout.addRow("Key File:", self.ssh_key_widget)

        ssh_group.setLayout(ssh_layout)

        # Add shadow effect
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(15)
        shadow.setXOffset(0)
        shadow.setYOffset(2)
        shadow.setColor(QColor(0, 0, 0, 30))
        ssh_group.setGraphicsEffect(shadow)

        main_layout.addWidget(ssh_group)

        # === Saved Profiles Group ===
        profiles_group = QGroupBox("Quick Connect")
        profiles_layout = QVBoxLayout()
        profiles_layout.setContentsMargins(10, 2, 10, 8)
        profiles_layout.setSpacing(6)

        # Profiles table (at the top)
        self.ssh_profiles_table = QTableWidget()
        self.ssh_profiles_table.setColumnCount(4)
        self.ssh_profiles_table.setHorizontalHeaderLabels(["Name", "Host", "Port", "Protocol"])
        self.ssh_profiles_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.ssh_profiles_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.ssh_profiles_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
        self.ssh_profiles_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.Stretch)
        self.ssh_profiles_table.setColumnWidth(2, 50)
        self.ssh_profiles_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.ssh_profiles_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.ssh_profiles_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.ssh_profiles_table.verticalHeader().setVisible(False)
        self.ssh_profiles_table.doubleClicked.connect(self.load_ssh_profile_from_table)
        self.ssh_profiles_table.setStyleSheet("""
            QTableWidget {
                background-color: #e8e8e8;
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                color: #333333;
                font-size: 9pt;
                gridline-color: #d0d0d0;
            }
            QTableWidget::item {
                padding: 4px;
                background-color: #e8e8e8;
            }
            QTableWidget::item:selected {
                background-color: #2196F3;
                color: white;
            }
            QHeaderView::section {
                background-color: #d0d0d0;
                color: #333333;
                padding: 4px;
                border: none;
                font-weight: bold;
                font-size: 9pt;
            }
        """)
        profiles_layout.addWidget(self.ssh_profiles_table)

        # Buttons row (centered, below table)
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(8)

        self.save_profile_btn = QPushButton("Save Current")
        self.save_profile_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.save_profile_btn.setStyleSheet("""
            QPushButton {
                background-color: #78909c;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #607d8b;
            }
        """)
        self.save_profile_btn.clicked.connect(self.save_current_ssh_profile)

        self.delete_profile_btn = QPushButton("Delete Selected")
        self.delete_profile_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.delete_profile_btn.setStyleSheet("""
            QPushButton {
                background-color: #9e9e9e;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #757575;
            }
        """)
        self.delete_profile_btn.clicked.connect(self.delete_ssh_profile)

        btn_layout.addStretch()
        btn_layout.addWidget(self.save_profile_btn)
        btn_layout.addWidget(self.delete_profile_btn)
        btn_layout.addStretch()
        profiles_layout.addLayout(btn_layout)

        profiles_group.setLayout(profiles_layout)

        # Add shadow
        shadow3 = QGraphicsDropShadowEffect()
        shadow3.setBlurRadius(15)
        shadow3.setXOffset(0)
        shadow3.setYOffset(2)
        shadow3.setColor(QColor(0, 0, 0, 30))
        profiles_group.setGraphicsEffect(shadow3)

        main_layout.addWidget(profiles_group, 1)  # stretch factor 1 to expand

        # Connect SSH button
        self.ssh_connect_btn = QPushButton("CONNECT SSH")
        self.ssh_connect_btn.setMinimumHeight(45)
        self.ssh_connect_btn.setFont(QFont("Sans Serif", 11, QFont.Weight.Bold))
        self.ssh_connect_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.ssh_connect_btn.setStyleSheet("""
            QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 8px;
                padding: 12px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #43a047;
            }
            QPushButton:pressed {
                background-color: #388e3c;
            }
        """)
        self.ssh_connect_btn.clicked.connect(self.connect_ssh)
        main_layout.addWidget(self.ssh_connect_btn)

        # SSH Status
        ssh_status_layout = QHBoxLayout()
        ssh_status_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        ssh_status_layout.setSpacing(8)

        self.ssh_status_led = QLabel("●")
        self.ssh_status_led.setStyleSheet("color: #4caf50; font-size: 14px;")

        self.ssh_status_label = QLabel("Ready for SSH connection")
        self.ssh_status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")

        ssh_status_layout.addWidget(self.ssh_status_led)
        ssh_status_layout.addWidget(self.ssh_status_label)

        ssh_status_widget = QWidget()
        ssh_status_widget.setLayout(ssh_status_layout)
        main_layout.addWidget(ssh_status_widget)

        page.setLayout(main_layout)

        # Load saved SSH profiles
        self.refresh_ssh_profiles()

        return page

    def get_icon_path(self, icon_name):
        """Get the path to an icon from assets/icons for different installation types"""
        # Check for Flatpak
        flatpak_path = f'/app/share/io.github.benjamimgois.serialcom/icons/{icon_name}'
        if os.path.exists(flatpak_path):
            return flatpak_path
        # Check for AppImage
        if os.environ.get('APPDIR'):
            appdir = os.environ.get('APPDIR')
            appimage_path = os.path.join(appdir, f'usr/share/serialcom/icons/{icon_name}')
            if os.path.exists(appimage_path):
                return appimage_path
        # Local installation or development - assets/icons
        assets_path = os.path.join(os.path.dirname(__file__), f'assets/icons/{icon_name}')
        if os.path.exists(assets_path):
            return assets_path
        # Legacy: root directory
        root_path = os.path.join(os.path.dirname(__file__), icon_name)
        if os.path.exists(root_path):
            return root_path
        return None

    def get_arrow_icon_path(self):
        """Get the path to arrow_down.svg"""
        return self.get_icon_path('arrow_down.svg') or ''

    def get_tab_icon_path(self, icon_name):
        """Get the path to tab icons"""
        return self.get_icon_path(icon_name)

    def apply_styles(self):
        """Apply modern light theme to the application"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f0f0f0;
            }
            QGroupBox {
                border: 1px solid #e8e8e8;
                border-radius: 8px;
                margin-top: 15px;
                padding-top: 18px;
                background-color: #ffffff;
                color: #2c2c2c;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 15px;
                padding: 0 8px;
                color: #2c2c2c;
                font-size: 11pt;
                font-weight: bold;
                background-color: #ffffff;
            }
            QComboBox {
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                padding: 4px 28px 4px 10px;
                background-color: #fafafa;
                min-height: 24px;
                color: #2c2c2c;
                font-size: 10pt;
            }
            QComboBox::drop-down {
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 25px;
                border-left: 1px solid #d0d0d0;
                border-top-right-radius: 5px;
                border-bottom-right-radius: 5px;
                background-color: transparent;
            }
            QComboBox::down-arrow {
                image: url(""" + self.get_arrow_icon_path() + """);
                width: 12px;
                height: 12px;
            }
            QComboBox:hover {
                border: 1px solid #a0a0a0;
                background-color: #ffffff;
            }
            QComboBox:focus {
                border: 2px solid #4caf50;
            }
            QComboBox QAbstractItemView {
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                background-color: #ffffff;
                selection-background-color: #e8f5e9;
                selection-color: #2c2c2c;
                color: #2c2c2c;
                padding: 4px;
                outline: none;
            }
            QComboBox QAbstractItemView::item {
                padding: 6px;
                min-height: 24px;
            }
            QComboBox QAbstractItemView::item:hover {
                background-color: #f5f5f5;
            }
            QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 8px;
                padding: 12px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #43a047;
            }
            QPushButton:pressed {
                background-color: #388e3c;
            }
            QLabel {
                color: #2c2c2c;
            }
            QFormLayout QLabel {
                color: #4a4a4a;
            }
            QMessageBox {
                background-color: #ffffff;
            }
            QMessageBox QLabel {
                color: #2c2c2c;
                font-size: 10pt;
            }
            QMessageBox QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px 16px;
                min-width: 80px;
            }
            QMessageBox QPushButton:hover {
                background-color: #43a047;
            }
            QToolTip {
                background-color: #424242;
                color: #ffffff;
                border: none;
                border-radius: 4px;
                padding: 5px 8px;
                font-size: 9pt;
            }
        """)

    def load_settings(self):
        """Load saved settings and apply to ComboBoxes"""
        # Load and set port type
        port_type = self.config.get('port_type')
        index = self.port_type.findText(port_type)
        if index >= 0:
            self.port_type.setCurrentIndex(index)

        # Load and set baudrate
        baudrate = self.config.get('baudrate')
        index = self.baudrate.findText(baudrate)
        if index >= 0:
            self.baudrate.setCurrentIndex(index)

        # Load and set databits
        databits = self.config.get('databits')
        index = self.databits.findText(databits)
        if index >= 0:
            self.databits.setCurrentIndex(index)

        # Load and set parity
        parity = self.config.get('parity')
        index = self.parity.findText(parity)
        if index >= 0:
            self.parity.setCurrentIndex(index)

        # Load and set stopbits
        stopbits = self.config.get('stopbits')
        index = self.stopbits.findText(stopbits)
        if index >= 0:
            self.stopbits.setCurrentIndex(index)

        # Load and set flow
        flow = self.config.get('flow')
        index = self.flow.findText(flow)
        if index >= 0:
            self.flow.setCurrentIndex(index)

        # Connect signals to save settings when changed
        self.port_type.currentTextChanged.connect(lambda text: self.config.set('port_type', text))
        self.baudrate.currentTextChanged.connect(lambda text: self.config.set('baudrate', text))
        self.databits.currentTextChanged.connect(lambda text: self.config.set('databits', text))
        self.parity.currentTextChanged.connect(lambda text: self.config.set('parity', text))
        self.stopbits.currentTextChanged.connect(lambda text: self.config.set('stopbits', text))
        self.flow.currentTextChanged.connect(lambda text: self.config.set('flow', text))

    def update_port_list(self):
        """Update the list of available ports"""
        self.port.clear()

        port_type = self.port_type.currentText()

        # Use glob to search for ports based on type
        if port_type == 'Serial':
            pattern = '/dev/ttyS*'
        else:  # USB
            pattern = '/dev/ttyUSB*'

        ports = sorted(glob.glob(pattern))

        if ports:
            self.port.addItems(ports)
            self.status_label.setText(f"{len(ports)} port(s) found")
            self.status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #4caf50; font-size: 14px;")
        else:
            self.port.addItem("No ports found")
            self.status_label.setText("No serial ports available")
            self.status_label.setStyleSheet("color: #ff9800; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #ff9800; font-size: 14px;")

    def update_network_interfaces(self):
        """Update the list of network interfaces"""
        self.tftp_interface.clear()
        interfaces = get_network_interfaces()

        if interfaces:
            for iface, ip in interfaces:
                self.tftp_interface.addItem(f"{iface} ({ip})", ip)
        else:
            self.tftp_interface.addItem("No interfaces found", "")

    def browse_tftp_directory(self):
        """Open dialog to select TFTP directory"""
        directory = QFileDialog.getExistingDirectory(
            self,
            "Select TFTP Directory",
            self.tftp_directory.text()
        )
        if directory:
            self.tftp_directory.setText(directory)

    def toggle_tftp_server(self):
        """Start or stop the TFTP server"""
        if self.tftp_process is not None:
            # Stop server
            self.tftp_process.terminate()
            self.tftp_process.wait()
            self.tftp_process = None
            self.tftp_btn.setText("Start TFTP")
            self.tftp_btn.setStyleSheet("""
                QPushButton {
                    background-color: #2196F3;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-weight: bold;
                    padding: 4px 16px;
                }
                QPushButton:hover {
                    background-color: #1976D2;
                }
            """)
            self.tftp_interface.setEnabled(True)
            self.tftp_directory.setEnabled(True)
            self.tftp_browse_btn.setEnabled(True)
        else:
            # Get selected interface IP
            ip = self.tftp_interface.currentData()
            if not ip:
                QMessageBox.warning(self, "Warning", "No network interface selected")
                return

            directory = self.tftp_directory.text()
            if not os.path.isdir(directory):
                QMessageBox.warning(self, "Warning", "Invalid TFTP directory")
                return

            # Ask for sudo password with custom dialog (to ensure light theme)
            password_dialog = QDialog(self)
            password_dialog.setWindowTitle("Sudo Password Required")
            password_dialog.setModal(True)
            password_dialog.setFixedSize(400, 150)
            
            # Apply light theme styling to dialog
            password_dialog.setStyleSheet("""
                QDialog {
                    background-color: #ffffff;
                }
                QLabel {
                    color: #2c2c2c;
                    font-size: 10pt;
                }
                QLineEdit {
                    background-color: #fafafa;
                    color: #2c2c2c;
                    border: 1px solid #d0d0d0;
                    border-radius: 6px;
                    padding: 8px;
                    font-size: 10pt;
                }
                QLineEdit:focus {
                    border: 2px solid #4caf50;
                }
                QPushButton {
                    background-color: #4caf50;
                    color: #ffffff;
                    border: none;
                    border-radius: 6px;
                    padding: 8px 16px;
                    font-weight: bold;
                    min-width: 80px;
                }
                QPushButton:hover {
                    background-color: #43a047;
                }
                QPushButton#cancelButton {
                    background-color: #9e9e9e;
                }
                QPushButton#cancelButton:hover {
                    background-color: #757575;
                }
            """)
            
            layout = QVBoxLayout()
            
            label = QLabel("TFTP port 69 requires root privileges.\nPlease enter your sudo password:")
            layout.addWidget(label)
            
            password_input = QLineEdit()
            password_input.setEchoMode(QLineEdit.EchoMode.Password)
            layout.addWidget(password_input)
            
            button_layout = QHBoxLayout()
            button_layout.addStretch()
            
            ok_button = QPushButton("OK")
            ok_button.clicked.connect(password_dialog.accept)
            button_layout.addWidget(ok_button)
            
            cancel_button = QPushButton("Cancel")
            cancel_button.setObjectName("cancelButton")
            cancel_button.clicked.connect(password_dialog.reject)
            button_layout.addWidget(cancel_button)
            
            layout.addLayout(button_layout)
            password_dialog.setLayout(layout)
            
            # Show dialog and get result
            if password_dialog.exec() != QDialog.DialogCode.Accepted:
                return
            
            password = password_input.text()
            if not password:
                return

            # Build command to run TFTP server with sudo
            script_path = os.path.abspath(__file__)
            cmd = ['sudo', '-S', sys.executable, script_path, '--tftp-server', ip, '69', directory]

            try:
                # Redirect TFTP server output to terminal for debugging
                print(f"[SerialCom] Starting TFTP server on {ip}:69")
                print(f"[SerialCom] Directory: {directory}")
                
                self.tftp_process = subprocess.Popen(
                    cmd,
                    stdin=subprocess.PIPE,
                    stdout=None,  # Inherit parent's stdout (terminal)
                    stderr=None,  # Inherit parent's stderr (terminal)
                    text=False
                )
                # Send password
                self.tftp_process.stdin.write((password + '\n').encode())
                self.tftp_process.stdin.flush()
                self.tftp_process.stdin.close()  # Close stdin after sending password
                password = None  # Clear from memory

                # Wait a moment to check if server started
                import time
                time.sleep(2.0)  # Increased timeout to allow server to start

                if self.tftp_process.poll() is not None:
                    # Process ended, probably failed
                    QMessageBox.critical(
                        self,
                        "Error",
                        f"Failed to start TFTP server.\n\nCheck terminal output for error details."
                    )
                    self.tftp_process = None
                    return

                print(f"[SerialCom] TFTP server started successfully")
                
                QMessageBox.information(
                    self,
                    "TFTP Server",
                    f"TFTP server started on {ip}:69\n\n"
                    f"Directory: {directory}\n\n"
                    f"Check terminal for debug messages."
                )

            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to start TFTP server.\n\n{str(e)}"
                )
                self.tftp_process = None
                return

            self.tftp_btn.setText("Stop TFTP")
            self.tftp_btn.setStyleSheet("""
                QPushButton {
                    background-color: #f44336;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-weight: bold;
                    padding: 4px 16px;
                }
                QPushButton:hover {
                    background-color: #d32f2f;
                }
            """)
            self.tftp_interface.setEnabled(False)
            self.tftp_directory.setEnabled(False)
            self.tftp_browse_btn.setEnabled(False)

    def build_picocom_command(self):
        """Build the picocom command with configured parameters"""
        port = self.port.currentText()

        if 'No ports found' in port or not port:
            return None

        baudrate = self.baudrate.currentText()
        databits = self.databits.currentText()

        # Parity
        parity_map = {'None': 'n', 'Even': 'e', 'Odd': 'o'}
        parity = parity_map[self.parity.currentText()]

        stopbits = self.stopbits.currentText()

        # Flow control
        flow_type = self.flow.currentText()
        if 'Hardware' in flow_type:
            flow = 'h'
        elif 'Software' in flow_type:
            flow = 's'
        else:
            flow = 'n'

        # Picocom command
        cmd = [
            'picocom',
            '-b', baudrate,
            '-d', databits,
            '-p', parity,
            '-f', flow,
            port
        ]

        # Add stop bits if 2
        if stopbits == '2':
            cmd.insert(-1, '-y')
            cmd.insert(-1, '2')

        return cmd

    # === SSH/Telnet Helper Methods ===

    def toggle_protocol(self, button):
        """Toggle between SSH and Telnet protocol"""
        if button == self.protocol_ssh_radio:
            # SSH selected
            self.ssh_port.setText("22")
            self.ssh_connect_btn.setText("CONNECT SSH")
        else:
            # Telnet selected
            self.ssh_port.setText("23")
            self.ssh_connect_btn.setText("CONNECT TELNET")

    def toggle_ssh_key(self, checked):
        """Toggle SSH key file widget visibility"""
        self.ssh_key_widget.setVisible(checked)

    def browse_ssh_key(self):
        """Open file dialog to select SSH private key"""
        key_file, _ = QFileDialog.getOpenFileName(
            self,
            "Select SSH Private Key",
            os.path.expanduser("~/.ssh"),
            "All Files (*)"
        )
        if key_file:
            self.ssh_key_path.setText(key_file)

    def refresh_ssh_profiles(self):
        """Refresh the SSH profiles table"""
        self.ssh_profiles_table.setRowCount(0)
        profiles = self.config.get_ssh_profiles()
        for profile in profiles:
            row = self.ssh_profiles_table.rowCount()
            self.ssh_profiles_table.insertRow(row)
            self.ssh_profiles_table.setItem(row, 0, QTableWidgetItem(profile.get('name', '')))
            self.ssh_profiles_table.setItem(row, 1, QTableWidgetItem(profile.get('host', '')))
            self.ssh_profiles_table.setItem(row, 2, QTableWidgetItem(profile.get('port', '22')))
            
            # Determine protocol based on port (22=SSH, 23=Telnet, or use saved protocol)
            port = profile.get('port', '22')
            protocol = profile.get('protocol', 'SSH' if port == '22' else 'Telnet' if port == '23' else 'SSH')
            self.ssh_profiles_table.setItem(row, 3, QTableWidgetItem(protocol))
            
            # Store profile data in first column item
            self.ssh_profiles_table.item(row, 0).setData(Qt.ItemDataRole.UserRole, profile)


    def load_ssh_profile_from_table(self):
        """Load selected SSH profile from table into form fields"""
        row = self.ssh_profiles_table.currentRow()
        if row < 0:
            return
        item = self.ssh_profiles_table.item(row, 0)
        if item:
            profile = item.data(Qt.ItemDataRole.UserRole)
            if profile:
                self.ssh_host.setText(profile.get('host', ''))
                self.ssh_port.setText(profile.get('port', '22'))
                self.ssh_username.setText(profile.get('username', ''))
                if profile.get('auth_method') == 'key':
                    self.use_ssh_key.setChecked(True)
                    self.ssh_key_path.setText(profile.get('key_path', ''))
                else:
                    self.use_ssh_key.setChecked(False)


    def save_current_ssh_profile(self):
        """Save current SSH settings as a profile"""
        host = self.ssh_host.text().strip()
        if not host:
            QMessageBox.warning(self, "Warning", "Enter a host before saving")
            return

        name, ok = QInputDialog.getText(self, "Save Profile", "Profile name:")
        if ok and name:
            auth_method = 'key' if self.use_ssh_key.isChecked() else 'password'
            protocol = 'SSH' if self.protocol_ssh_radio.isChecked() else 'Telnet'
            self.config.save_ssh_profile(
                name, host, self.ssh_port.text(),
                self.ssh_username.text(), auth_method,
                self.ssh_key_path.text() if auth_method == 'key' else '',
                protocol
            )
            self.refresh_ssh_profiles()
            QMessageBox.information(self, "Saved", f"Profile '{name}' saved")

    def delete_ssh_profile(self):
        """Delete selected SSH profile from table"""
        row = self.ssh_profiles_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "Warning", "Select a profile to delete")
            return
        item = self.ssh_profiles_table.item(row, 0)
        if item:
            profile = item.data(Qt.ItemDataRole.UserRole)
            if profile:
                reply = QMessageBox.question(
                    self, "Delete Profile",
                    f"Delete profile '{profile['name']}'?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    self.config.delete_ssh_profile(profile['name'])
                    self.refresh_ssh_profiles()

    def connect_ssh(self):
        """Connect via SSH or Telnet"""
        host = self.ssh_host.text().strip()
        port = self.ssh_port.text().strip() or "22"
        username = self.ssh_username.text().strip()

        if not host:
            QMessageBox.warning(self, "Warning", "Enter host address")
            return

        # Check if Telnet is selected
        if self.protocol_telnet_radio.isChecked():
            # Telnet connection
            self.ssh_status_label.setText("Connecting...")
            self.ssh_status_label.setStyleSheet("color: #ff9800; font-size: 10pt;")
            self.ssh_status_led.setStyleSheet("color: #ff9800; font-size: 14px;")
            QApplication.processEvents()

            self.terminal_dialog = TerminalDialog(self, self.config)

            if self.terminal_dialog.start_telnet(host, port, username):
                self.ssh_status_label.setText("Connected - Terminal opened")
                self.ssh_status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")
                self.ssh_status_led.setStyleSheet("color: #4caf50; font-size: 14px;")
                self.terminal_dialog.exec()

                # Reset status
                self.ssh_status_label.setText("Ready for connection")
                self.ssh_status_label.setStyleSheet("color: #2196F3; font-size: 10pt;")
                self.ssh_status_led.setStyleSheet("color: #2196F3; font-size: 14px;")
            else:
                self.ssh_status_label.setText("Connection failed")
                self.ssh_status_label.setStyleSheet("color: #f44336; font-size: 10pt;")
                self.ssh_status_led.setStyleSheet("color: #f44336; font-size: 14px;")
            return

        # SSH connection
        if not SSH_AVAILABLE:
            QMessageBox.critical(
                self, "Error",
                "paramiko library is not installed.\n\n"
                "Install with: pip install paramiko"
            )
            return

        if not username:
            QMessageBox.warning(self, "Warning", "Enter host and username")
            return

        # Get authentication credentials
        password = None
        key_path = None

        if self.use_ssh_key.isChecked():
            # SSH Key authentication
            key_path = self.ssh_key_path.text().strip()
            if not key_path:
                QMessageBox.warning(self, "Warning", "Select SSH key file")
                return
            key_path = os.path.expanduser(key_path)
        else:
            # Password authentication
            password = self.ssh_password.text()
            if not password:
                # Prompt for password if not entered
                password, ok = QInputDialog.getText(
                    self, "SSH Password",
                    f"Password for {username}@{host}:",
                    QLineEdit.EchoMode.Password
                )
                if not ok:
                    return

        # Update status
        self.ssh_status_label.setText("Connecting...")
        self.ssh_status_label.setStyleSheet("color: #ff9800; font-size: 10pt;")
        self.ssh_status_led.setStyleSheet("color: #ff9800; font-size: 14px;")
        QApplication.processEvents()

        # Create terminal dialog
        self.terminal_dialog = TerminalDialog(self, self.config)

        if self.terminal_dialog.start_ssh(host, port, username, password, key_path):
            self.ssh_status_label.setText("Connected - Terminal opened")
            self.ssh_status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")
            self.ssh_status_led.setStyleSheet("color: #4caf50; font-size: 14px;")
            self.terminal_dialog.exec()

            # Reset status
            self.ssh_status_label.setText("Ready for SSH connection")
            self.ssh_status_label.setStyleSheet("color: #2196F3; font-size: 10pt;")
            self.ssh_status_led.setStyleSheet("color: #2196F3; font-size: 14px;")
        else:
            self.ssh_status_label.setText("Connection failed")
            self.ssh_status_label.setStyleSheet("color: #f44336; font-size: 10pt;")
            self.ssh_status_led.setStyleSheet("color: #f44336; font-size: 14px;")

    def connect(self):
        """Connect to the serial port using embedded terminal"""
        # Check if debug mode is enabled
        if self.debug_checkbox.isChecked():
            self.status_label.setText("Opening debug terminal...")
            self.status_label.setStyleSheet("color: #fab387; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #fab387; font-size: 14px;")
            QApplication.processEvents()

            # Create and show terminal dialog in debug mode
            self.terminal_dialog = TerminalDialog(self, self.config)
            self.terminal_dialog.start_debug_mode()
            self.status_label.setText("Debug Mode - Terminal opened")
            self.status_label.setStyleSheet("color: #a6e3a1; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #a6e3a1; font-size: 14px;")
            self.terminal_dialog.exec()

            # Reset status after terminal closes
            self.status_label.setText("Ready to connect")
            self.status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #4caf50; font-size: 14px;")
            return

        # Check if picocom is installed
        try:
            subprocess.run(['which', 'picocom'], check=True, capture_output=True)
        except subprocess.CalledProcessError:
            QMessageBox.critical(
                self,
                "Error",
                "picocom is not installed.\n\n"
                "Install with:\nsudo pacman -S picocom"
            )
            return

        # Build command
        cmd = self.build_picocom_command()

        if not cmd:
            QMessageBox.warning(
                self,
                "Warning",
                "Select a valid serial port"
            )
            return

        self.status_label.setText("Opening terminal...")
        self.status_label.setStyleSheet("color: #fab387; font-size: 10pt;")
        self.status_led.setStyleSheet("color: #fab387; font-size: 14px;")
        QApplication.processEvents()

        # Create and show terminal dialog
        self.terminal_dialog = TerminalDialog(self, self.config)

        # Start picocom
        if self.terminal_dialog.start_picocom(cmd):
            self.status_label.setText("Connected - Terminal opened")
            self.status_label.setStyleSheet("color: #a6e3a1; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #a6e3a1; font-size: 14px;")
            self.terminal_dialog.exec()

            # Reset status after terminal closes
            self.status_label.setText("Ready to connect")
            self.status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #4caf50; font-size: 14px;")
        else:
            self.status_label.setText("Connection error")
            self.status_label.setStyleSheet("color: #f38ba8; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #f38ba8; font-size: 14px;")


def main():
    app = QApplication(sys.argv)

    # Set default font
    font = QFont("Sans Serif", 9)
    app.setFont(font)

    window = SerialTerminalGUI()
    window.show()

    sys.exit(app.exec())


if __name__ == '__main__':
    main()
