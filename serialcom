#!/usr/bin/env python3
"""
SerialCom - Graphical interface for serial communication via picocom
Version: 1.1
"""

import sys
import os
import subprocess
import glob
import json
import socket
import threading
import socketserver
import telnetlib
from pathlib import Path

# Application version
VERSION = "1.2"


class TFTPHandler(socketserver.BaseRequestHandler):
    """Simple TFTP request handler supporting RRQ (read) operations"""

    TFTP_OPCODES = {
        1: 'RRQ',   # Read request
        2: 'WRQ',   # Write request
        3: 'DATA',  # Data
        4: 'ACK',   # Acknowledgment
        5: 'ERROR'  # Error
    }

    def handle(self):
        data, sock = self.request
        opcode = int.from_bytes(data[0:2], 'big')

        if opcode == 1:  # RRQ - Read Request
            self.handle_rrq(data, sock)
        elif opcode == 2:  # WRQ - Write Request
            self.handle_wrq(data, sock)

    def handle_rrq(self, data, sock):
        """Handle read request - send file to client"""
        # Parse filename from request
        parts = data[2:].split(b'\x00')
        filename = parts[0].decode('utf-8')

        # Get the file path from server's root directory
        filepath = os.path.join(self.server.tftp_root, filename)

        if not os.path.exists(filepath):
            # Send error: File not found
            error_packet = b'\x00\x05\x00\x01File not found\x00'
            sock.sendto(error_packet, self.client_address)
            print(f"[TFTP] File not found: {filename}")
            return

        try:
            with open(filepath, 'rb') as f:
                block_num = 1
                while True:
                    file_data = f.read(512)
                    # Build DATA packet: opcode (2 bytes) + block# (2 bytes) + data
                    data_packet = b'\x00\x03' + block_num.to_bytes(2, 'big') + file_data
                    sock.sendto(data_packet, self.client_address)

                    # Wait for ACK
                    sock.settimeout(5.0)
                    try:
                        ack_data, _ = sock.recvfrom(516)
                        ack_opcode = int.from_bytes(ack_data[0:2], 'big')
                        ack_block = int.from_bytes(ack_data[2:4], 'big')

                        if ack_opcode != 4 or ack_block != block_num:
                            print(f"[TFTP] Unexpected ACK: opcode={ack_opcode}, block={ack_block}")
                            break
                    except socket.timeout:
                        print(f"[TFTP] Timeout waiting for ACK block {block_num}")
                        break

                    if len(file_data) < 512:
                        # Last block sent
                        print(f"[TFTP] Transfer complete: {filename}")
                        break

                    block_num += 1

        except Exception as e:
            error_packet = b'\x00\x05\x00\x00' + str(e).encode() + b'\x00'
            sock.sendto(error_packet, self.client_address)
            print(f"[TFTP] Error reading file: {e}")

    def handle_wrq(self, data, sock):
        """Handle write request - receive file from client"""
        # Parse filename from request
        parts = data[2:].split(b'\x00')
        filename = parts[0].decode('utf-8')

        # Get the file path in server's root directory
        filepath = os.path.join(self.server.tftp_root, filename)

        try:
            # Send ACK for block 0 to start transfer
            ack_packet = b'\x00\x04\x00\x00'
            sock.sendto(ack_packet, self.client_address)

            with open(filepath, 'wb') as f:
                block_num = 1
                while True:
                    sock.settimeout(5.0)
                    try:
                        data_packet, _ = sock.recvfrom(516)
                        opcode = int.from_bytes(data_packet[0:2], 'big')
                        recv_block = int.from_bytes(data_packet[2:4], 'big')

                        if opcode != 3 or recv_block != block_num:
                            print(f"[TFTP] Unexpected DATA: opcode={opcode}, block={recv_block}")
                            break

                        file_data = data_packet[4:]
                        f.write(file_data)

                        # Send ACK
                        ack_packet = b'\x00\x04' + block_num.to_bytes(2, 'big')
                        sock.sendto(ack_packet, self.client_address)

                        if len(file_data) < 512:
                            print(f"[TFTP] Receive complete: {filename}")
                            break

                        block_num += 1

                    except socket.timeout:
                        print(f"[TFTP] Timeout waiting for DATA block {block_num}")
                        break

        except Exception as e:
            error_packet = b'\x00\x05\x00\x00' + str(e).encode() + b'\x00'
            sock.sendto(error_packet, self.client_address)
            print(f"[TFTP] Error writing file: {e}")


class TFTPServer:
    """Simple TFTP Server"""

    def __init__(self, host='0.0.0.0', port=69, root_dir=None):
        self.host = host
        self.port = port
        # Use XDG HOME for Flatpak compatibility
        self.root_dir = root_dir or os.environ.get('HOME', str(Path.home()))
        self.server = None
        self.thread = None
        self.running = False

    def start(self):
        """Start the TFTP server in a background thread"""
        if self.running:
            return False

        try:
            self.server = socketserver.UDPServer((self.host, self.port), TFTPHandler)
            self.server.tftp_root = self.root_dir
            self.thread = threading.Thread(target=self._serve, daemon=True)
            self.thread.start()
            self.running = True
            print(f"[TFTP] Server started on {self.host}:{self.port}, root: {self.root_dir}")
            return True
        except PermissionError:
            print(f"[TFTP] Permission denied for port {self.port}. Try running with sudo or use port > 1024")
            return False
        except Exception as e:
            print(f"[TFTP] Failed to start server: {e}")
            return False

    def _serve(self):
        """Serve requests until stopped"""
        try:
            self.server.serve_forever()
        except Exception as e:
            print(f"[TFTP] Server error: {e}")
            self.running = False

    def stop(self):
        """Stop the TFTP server"""
        if not self.running:
            return

        self.running = False
        if self.server:
            try:
                self.server.shutdown()
                self.server.server_close()
            except Exception as e:
                print(f"[TFTP] Error stopping server: {e}")
            finally:
                self.server = None
        print("[TFTP] Server stopped")

    def is_running(self):
        return self.running


def run_tftp_server_standalone(host, port, directory):
    """Run TFTP server in standalone mode (for sudo execution)"""
    import signal

    server = TFTPServer(host=host, port=port, root_dir=directory)

    def signal_handler(signum, frame):
        print("\n[TFTP] Stopping server...")
        server.stop()
        sys.exit(0)

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    if server.start():
        print(f"[TFTP] Server running on {host}:{port}")
        print(f"[TFTP] Directory: {directory}")
        print("[TFTP] Press Ctrl+C to stop")
        # Keep running until signal
        while server.is_running():
            import time
            time.sleep(1)
    else:
        print("[TFTP] Failed to start server")
        sys.exit(1)


# Check for TFTP server mode early (before importing GUI libraries)
# This allows the TFTP server to run with sudo without requiring
# PyQt6 and pyte to be installed system-wide
if __name__ == '__main__' and len(sys.argv) >= 5 and sys.argv[1] == '--tftp-server':
    host = sys.argv[2]
    port = int(sys.argv[3])
    directory = sys.argv[4]
    run_tftp_server_standalone(host, port, directory)
    sys.exit(0)


# Import GUI libraries (only reached if not in TFTP server mode)
import pyte
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QComboBox, QPushButton, QGroupBox, QFormLayout, QMessageBox,
    QTextEdit, QPlainTextEdit, QDialog, QInputDialog, QLineEdit,
    QGraphicsDropShadowEffect, QCheckBox, QFileDialog,
    QStackedWidget, QRadioButton, QButtonGroup, QTableWidget,
    QTableWidgetItem, QHeaderView, QAbstractItemView, QSizePolicy,
    QMenu
)
from PyQt6.QtCore import Qt, QProcess, pyqtSignal, QTimer, QThread
from PyQt6.QtGui import QFont, QTextCursor, QKeyEvent, QTextBlockFormat, QTextCharFormat, QColor, QPixmap, QIcon, QTextOption

try:
    from PyQt6.QtSerialPort import QSerialPortInfo
    SERIAL_PORT_AVAILABLE = True
except ImportError:
    SERIAL_PORT_AVAILABLE = False

try:
    import paramiko
    SSH_AVAILABLE = True
except ImportError:
    SSH_AVAILABLE = False


def get_network_interfaces():
    """Get list of network interfaces with their IP addresses"""
    interfaces = []

    try:
        # Use ip command to get interface information
        result = subprocess.run(['ip', '-4', 'addr', 'show'], capture_output=True, text=True)

        current_iface = None
        for line in result.stdout.split('\n'):
            # Match interface line (e.g., "2: eth0: <BROADCAST...")
            if ': ' in line and not line.startswith(' '):
                parts = line.split(': ')
                if len(parts) >= 2:
                    current_iface = parts[1].split('@')[0]

            # Match inet line (e.g., "    inet 192.168.1.100/24...")
            elif 'inet ' in line and current_iface:
                parts = line.strip().split()
                if len(parts) >= 2:
                    ip_with_mask = parts[1]
                    ip = ip_with_mask.split('/')[0]
                    if ip != '127.0.0.1':  # Skip loopback
                        interfaces.append((current_iface, ip))
    except Exception as e:
        print(f"Error getting interfaces: {e}")

    return interfaces


class ConfigManager:
    """Manage application settings using XDG Base Directory specification"""

    def __init__(self):
        # Get XDG config directory (defaults to ~/.config)
        xdg_config_home = os.environ.get('XDG_CONFIG_HOME')
        if not xdg_config_home:
            xdg_config_home = os.path.join(Path.home(), '.config')

        # Create serialcom config directory
        self.config_dir = os.path.join(xdg_config_home, 'serialcom')
        os.makedirs(self.config_dir, exist_ok=True)

        # Config file path
        self.config_file = os.path.join(self.config_dir, 'settings.json')

        # Default settings
        self.defaults = {
            # Serial settings
            'port_type': 'USB',
            'baudrate': '9600',
            'databits': '8',
            'parity': 'None',
            'stopbits': '1',
            'flow': 'None',
            'vendor': 'Default',
            # Connection mode
            'connection_mode': 'serial',
            # SSH settings
            'ssh_host': '',
            'ssh_port': '22',
            'ssh_username': '',
            'ssh_auth_method': 'password',
            'ssh_key_path': '',
            'ssh_profiles': '[]',
            # Serial profiles
            'serial_profiles': '[]'
        }

        # Load settings
        self.settings = self.load()

    def load(self):
        """Load settings from file, return defaults if file doesn't exist"""
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    loaded = json.load(f)
                    # Merge with defaults (in case new settings were added)
                    return {**self.defaults, **loaded}
            except (json.JSONDecodeError, IOError) as e:
                print(f"Warning: Could not load settings: {e}")
                return self.defaults.copy()
        return self.defaults.copy()

    def save(self):
        """Save settings to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.settings, f, indent=4)
        except IOError as e:
            print(f"Warning: Could not save settings: {e}")

    def set(self, key, value):
        """Set a setting value and save"""
        self.settings[key] = value
        self.save()

    def get(self, key):
        """Get a setting value"""
        return self.settings.get(key, self.defaults.get(key))

    def get_ssh_profiles(self):
        """Get list of saved SSH connection profiles"""
        profiles_json = self.settings.get('ssh_profiles', '[]')
        try:
            return json.loads(profiles_json)
        except json.JSONDecodeError:
            return []

    def save_ssh_profile(self, name, host, port, username, auth_method, key_path='', protocol='SSH'):
        """Save an SSH connection profile"""
        profiles = self.get_ssh_profiles()
        # Update existing or add new
        for i, p in enumerate(profiles):
            if p.get('name') == name:
                profiles[i] = {
                    'name': name, 'host': host, 'port': port,
                    'username': username, 'auth_method': auth_method,
                    'key_path': key_path, 'protocol': protocol
                }
                break
        else:
            profiles.append({
                'name': name, 'host': host, 'port': port,
                'username': username, 'auth_method': auth_method,
                'key_path': key_path, 'protocol': protocol
            })
        self.set('ssh_profiles', json.dumps(profiles))

    def delete_ssh_profile(self, name):
        """Delete an SSH connection profile"""
        profiles = [p for p in self.get_ssh_profiles() if p.get('name') != name]
        self.set('ssh_profiles', json.dumps(profiles))

    def get_serial_profiles(self):
        """Get list of saved serial connection profiles"""
        profiles_json = self.settings.get('serial_profiles', '[]')
        try:
            return json.loads(profiles_json)
        except json.JSONDecodeError:
            return []

    def save_serial_profile(self, name, port, baudrate, databits, parity, stopbits, flow):
        """Save a serial connection profile"""
        profiles = self.get_serial_profiles()
        for i, p in enumerate(profiles):
            if p.get('name') == name:
                profiles[i] = {
                    'name': name, 'port': port, 'baudrate': baudrate,
                    'databits': databits, 'parity': parity,
                    'stopbits': stopbits, 'flow': flow
                }
                break
        else:
            profiles.append({
                'name': name, 'port': port, 'baudrate': baudrate,
                'databits': databits, 'parity': parity,
                'stopbits': stopbits, 'flow': flow
            })
        self.set('serial_profiles', json.dumps(profiles))

    def delete_serial_profile(self, name):
        """Delete a serial connection profile"""
        profiles = [p for p in self.get_serial_profiles() if p.get('name') != name]
        self.set('serial_profiles', json.dumps(profiles))


class TerminalWidget(QTextEdit):
    """Terminal widget using pyte for proper VT100/ANSI emulation"""

    send_input = pyqtSignal(str)
    size_changed = pyqtSignal(int, int)  # columns, lines

    def __init__(self, parent=None, columns=120, lines=40):
        super().__init__(parent)
        self.setReadOnly(True)  # Terminal handles all input
        self.font_size = 10  # Default font size
        self.vendor = "Default"  # Default vendor for syntax highlighting
        self.setFont(QFont("Monospace", self.font_size))

        # Track mouse state for selection
        self.mouse_pressed = False

        # Configure line wrap mode to prevent weird selection behavior
        self.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap)

        # Set word wrap mode for better text selection
        self.setWordWrapMode(QTextOption.WrapMode.NoWrap)

        # Prevent Tab from being used for focus navigation
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.setTabChangesFocus(False)

        # Initialize pyte terminal emulator with scrollback history
        self.screen = pyte.HistoryScreen(columns, lines, history=5000)
        self.stream = pyte.Stream(self.screen)

        # Scrollback buffer: pre-rendered HTML lines that scrolled off the top
        self._scrollback_lines = []
        self._scrollback_cache = ""
        self._scrollback_dirty = False
        self._max_scrollback = 5000
        self._render_needed = True  # Dirty flag to avoid redundant setHtml calls
        self._in_scrollback_mode = False  # True when user is browsing history

        # Refresh timer for rendering
        self.refresh_timer = QTimer()
        self.refresh_timer.timeout.connect(self.render_screen)
        self.refresh_timer.start(50)  # Refresh every 50ms

        # Apply terminal styling
        self.setStyleSheet("""
            QTextEdit {
                background-color: #0a0a0a;
                color: #e0e0e0;
                border: none;
                padding: 10px;
            }
        """)

    def event(self, event):
        """Intercept Tab key before focus handling"""
        if event.type() == event.Type.KeyPress:
            if event.key() == Qt.Key.Key_Tab:
                # Handle Tab directly here, don't let it propagate
                self.send_input.emit('\t')
                event.accept()
                return True
        return super().event(event)

    def wheelEvent(self, event):
        """Enter scrollback mode when user scrolls up"""
        if event.angleDelta().y() > 0 and not self._in_scrollback_mode and self._scrollback_lines:
            self._enter_scrollback_mode()
        super().wheelEvent(event)

    def _enter_scrollback_mode(self):
        """Inject scrollback into document so user can browse history"""
        cursor_x = self.screen.cursor.x
        cursor_y = self.screen.cursor.y
        screen_lines = []
        for y in range(self.screen.lines):
            cx = cursor_x if y == cursor_y else None
            screen_lines.append(self._render_line(self.screen.buffer[y], self.screen.columns, cursor_x=cx))

        pre_open = '<pre style="margin: 0; padding: 0; line-height: 1.2; user-select: text; -webkit-user-select: text;">'
        if self._scrollback_cache:
            full_html = pre_open + self._scrollback_cache + '\n' + '\n'.join(screen_lines) + '</pre>'
        else:
            full_html = pre_open + '\n'.join(screen_lines) + '</pre>'

        self.setUpdatesEnabled(False)
        self.setHtml(full_html)
        scrollbar = self.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
        self.setUpdatesEnabled(True)
        self._in_scrollback_mode = True

    def mousePressEvent(self, event):
        """Track mouse press for selection"""
        self.mouse_pressed = True
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        """Track mouse release after selection"""
        self.mouse_pressed = False
        super().mouseReleaseEvent(event)

    def contextMenuEvent(self, event):
        """Show right-click context menu with copy, paste and export options"""
        # Pre-fetch clipboard text before showing menu to avoid delay on paste
        clipboard_text = QApplication.clipboard().text()

        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #1e1e2e;
                color: #cdd6f4;
                border: 1px solid #585b70;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 3px;
            }
            QMenu::item:selected {
                background-color: #45475a;
            }
        """)
        copy_action = menu.addAction("Copy")
        copy_action.setEnabled(self.textCursor().hasSelection())
        paste_action = menu.addAction("Paste")
        paste_action.setEnabled(bool(clipboard_text))
        menu.addSeparator()
        export_action = menu.addAction("Export to file...")

        action = menu.exec(event.globalPos())
        # Reset mouse_pressed since the release happened over the menu, not the terminal
        self.mouse_pressed = False

        if action == copy_action:
            text = self.textCursor().selectedText()
            if text:
                QApplication.clipboard().setText(text)
        elif action == paste_action:
            self._paste_clipboard(clipboard_text)
        elif action == export_action:
            self._export_terminal()

    def _paste_clipboard(self, text):
        """Paste clipboard text into the terminal"""
        if text:
            self.send_input.emit(text)

    def _export_terminal(self):
        """Export full terminal content (scrollback + current screen) to a text file"""
        path, _ = QFileDialog.getSaveFileName(
            self, "Export Terminal", "", "Text files (*.txt);;All files (*)"
        )
        if not path:
            return
        # Build plain text from scrollback HTML lines
        import re
        tag_re = re.compile(r'<[^>]+>')
        lines = []
        for html_line in self._scrollback_lines:
            plain = tag_re.sub('', html_line)
            plain = plain.replace('&amp;', '&').replace('&lt;', '<').replace('&gt;', '>').replace('&nbsp;', ' ')
            lines.append(plain)
        # Append current screen content
        for y in range(self.screen.lines):
            row = self.screen.buffer[y]
            line = ''.join(row[x].data for x in range(self.screen.columns)).rstrip()
            lines.append(line)
        with open(path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines) + '\n')

    def keyPressEvent(self, event: QKeyEvent):
        """Handle key press and send to picocom"""
        key = event.key()
        modifiers = event.modifiers()
        text = event.text()

        # Build key sequence to send
        sequence = ""

        # Handle Ctrl combinations
        if modifiers & Qt.KeyboardModifier.ControlModifier:
            if key == Qt.Key.Key_F:
                # Focus search input in parent dialog
                dialog = self.parent()
                if hasattr(dialog, 'search_input'):
                    dialog.search_input.setFocus()
                    dialog.search_input.selectAll()
                return
            elif key == Qt.Key.Key_A:
                sequence = '\x01'
            elif key == Qt.Key.Key_C:
                sequence = '\x03'
            elif key == Qt.Key.Key_D:
                sequence = '\x04'
            elif key == Qt.Key.Key_H:
                sequence = '\x08'
            elif key == Qt.Key.Key_L:
                sequence = '\x0c'
            elif key == Qt.Key.Key_U:
                sequence = '\x15'
            elif key == Qt.Key.Key_X:
                sequence = '\x18'
            elif key == Qt.Key.Key_Z:
                sequence = '\x1a'

        # Handle special keys
        elif key == Qt.Key.Key_Return or key == Qt.Key.Key_Enter:
            sequence = '\r'
        elif key == Qt.Key.Key_Backspace:
            sequence = '\x7f'
        elif key == Qt.Key.Key_Tab:
            sequence = '\t'
        elif key == Qt.Key.Key_Up:
            sequence = '\x1b[A'
        elif key == Qt.Key.Key_Down:
            sequence = '\x1b[B'
        elif key == Qt.Key.Key_Right:
            sequence = '\x1b[C'
        elif key == Qt.Key.Key_Left:
            sequence = '\x1b[D'
        elif key == Qt.Key.Key_Home:
            sequence = '\x1b[H'
        elif key == Qt.Key.Key_End:
            sequence = '\x1b[F'
        elif key == Qt.Key.Key_Delete:
            sequence = '\x1b[3~'
        elif key == Qt.Key.Key_PageUp:
            sequence = '\x1b[5~'
        elif key == Qt.Key.Key_PageDown:
            sequence = '\x1b[6~'
        elif text:
            sequence = text

        # Send sequence to picocom/SSH
        if sequence:
            print(f"[DEBUG] Key pressed, sending: {repr(sequence)}")
            self.send_input.emit(sequence)

    def append_output(self, text):
        """Feed text to pyte terminal emulator"""
        self.stream.feed(text)
        self._render_needed = True

    def set_vendor(self, vendor):
        """Set the vendor for syntax highlighting"""
        self.vendor = vendor

    def get_vendor_keywords(self):
        """Get keywords specific to the selected vendor"""
        # Common keywords for all vendors
        common = ['vlan', 'ip', 'ipv6', 'address', 'shutdown', 'route', 'static',
                  'permit', 'deny', 'any', 'host', 'password', 'secret', 'description',
                  'protocol', 'snmp', 'community', 'version', 'dhcp', 'server', 'pool',
                  'gateway', 'dns', 'lease', 'ntp', 'authentication', 'key', 'logging']

        # Cisco IOS/IOS-XE specific
        cisco = common + [
            'interface', 'no', 'router', 'bgp', 'ospf', 'eigrp', 'rip', 'isis',
            'access-list', 'line', 'vty', 'console', 'enable', 'service', 'hostname',
            'banner', 'switchport', 'mode', 'trunk', 'access', 'native', 'allowed',
            'spanning-tree', 'portfast', 'bpduguard', 'channel-group', 'lacp', 'pagp',
            'ssh', 'telnet', 'http', 'https', 'aaa', 'radius', 'tacacs',
            'port-security', 'maximum', 'violation', 'sticky', 'aging', 'time',
            'show', 'running-config', 'startup-config', 'brief', 'status', 'summary',
            'detail', 'controllers', 'inventory', 'copy', 'write', 'erase', 'reload',
            'configure', 'terminal', 'end', 'exit', 'crypto', 'isakmp', 'ipsec'
        ]

        # Huawei VRP specific
        huawei = common + [
            'display', 'system-view', 'quit', 'return', 'save', 'undo', 'sysname',
            'interface', 'user-interface', 'authentication-mode', 'aaa', 'local-user',
            'privilege', 'level', 'acl', 'rule', 'source', 'destination', 'basic',
            'advanced', 'mac-address', 'port-isolate', 'eth-trunk', 'mode', 'lacp',
            'stp', 'bpdu', 'edged-port', 'ssh', 'telnet', 'client', 'server',
            'cipher', 'hmac', 'exchange', 'dh-exchange', 'header', 'dot1x', 'vlan',
            'batch', 'port', 'hybrid', 'trunk', 'access', 'voice-vlan', 'qinq',
            'current-configuration', 'saved-configuration', 'startup', 'next'
        ]

        # H3C Comware specific
        h3c = common + [
            'display', 'system-view', 'quit', 'return', 'save', 'undo', 'sysname',
            'interface', 'user-interface', 'authentication-mode', 'local-user',
            'authorization-mode', 'accounting-mode', 'acl', 'rule', 'basic', 'advanced',
            'link-aggregation', 'lacp', 'stp', 'bpdu-protection', 'edge-port',
            'ssh', 'telnet', 'server', 'port-security', 'mac-address', 'port',
            'hybrid', 'trunk', 'access', 'voice', 'current-configuration', 'lldp'
        ]

        # Juniper Junos specific
        juniper = common + [
            'set', 'delete', 'show', 'commit', 'rollback', 'configure', 'edit',
            'top', 'up', 'interfaces', 'protocols', 'routing-options', 'firewall',
            'security', 'zones', 'policies', 'nat', 'chassis', 'system', 'services'
        ]

        # D-Link specific
        dlink = common + [
            'create', 'delete', 'config', 'show', 'enable', 'disable', 'vlan',
            'ports', 'stp', 'igmp', 'snmp', 'fdb', 'address_binding', 'vlanname',
            'link_aggregation', 'group', 'master', 'member', 'lacp', 'state',
            'traffic_control', 'broadcast', 'multicast', 'unicast', 'action',
            'access_profile', 'access_list', 'packet_content_mask', 'profile_id',
            'bpdu_tunnel', 'tunnel_mac', 'loopdetect', 'recover_timer', 'interval',
            'safeguard_engine', 'rising_threshold', 'falling_threshold', 'mode',
            'download', 'upload', 'save', 'reboot', 'reset', 'factory_default',
            'ip_source_guard', 'verify_source', 'trust', 'max_dynamic_hosts',
            'traffic_segmentation', 'forward_list', 'block', 'mirror', 'session',
            'source', 'destination', 'port_mirror', 'flow_mirror', 'cpu_filter'
        ]

        # Brocade Fabric OS specific
        brocade = common + [
            'switchshow', 'switchname', 'switchdisable', 'switchenable', 'configshow',
            'configupload', 'configdownload', 'configdefault', 'fabricshow',
            'portshow', 'portcfgshow', 'portdisable', 'portenable', 'portname',
            'portcfgpersistentdisable', 'portcfgpersistentenable', 'switchportshow',
            'aliacreate', 'aliadd', 'aliremove', 'alidelete', 'alishow',
            'zonecreate', 'zoneadd', 'zoneremove', 'zonedelete', 'zoneshow',
            'cfgcreate', 'cfgadd', 'cfgremove', 'cfgdelete', 'cfgshow', 'cfgenable',
            'cfgdisable', 'cfgsave', 'cfgclear', 'defzone', 'nozoning',
            'firmwareshow', 'firmwaredownload', 'firmwaredownloadstatus', 'version',
            'licenseshow', 'licenseadd', 'licenseremove', 'licenseport',
            'ipaddrset', 'ipaddrshow', 'nsshow', 'nsallshow', 'nscamshow',
            'reboot', 'fastboot', 'hashow', 'failover', 'setcontext',
            'tsclockserver', 'tstimezone', 'date', 'uptime', 'diagshow', 'supportshow'
        ]

        # Datacom specific (Brazilian manufacturer)
        datacom = common + [
            'show', 'configure', 'interface', 'vlan', 'no', 'router', 'bgp', 'ospf',
            'eigrp', 'rip', 'access-list', 'line', 'vty', 'console', 'enable',
            'service', 'hostname', 'banner', 'switchport', 'mode', 'trunk', 'access',
            'spanning-tree', 'portfast', 'port-channel', 'lacp', 'etherchannel',
            'ssh', 'telnet', 'http', 'snmp-server', 'ntp', 'clock', 'timezone',
            'aaa', 'radius', 'tacacs', 'local-user', 'privilege', 'level',
            'qos', 'class-map', 'policy-map', 'service-policy', 'trust', 'dscp',
            'write', 'memory', 'reload', 'copy', 'running-config', 'startup-config',
            'erase', 'boot', 'system', 'flash', 'tftp', 'ftp', 'upload', 'download',
            'mac', 'mac-address-table', 'aging-time', 'storm-control', 'broadcast',
            'errdisable', 'recovery', 'cause', 'interval', 'speed', 'duplex', 'mtu',
            'description', 'default-gateway', 'ip-address', 'subnet-mask', 'vrf'
        ]

        # Fortinet FortiOS specific (Firewall)
        fortinet = common + [
            'config', 'end', 'next', 'edit', 'delete', 'show', 'get', 'set', 'unset',
            'execute', 'diagnose', 'purge', 'rename', 'clone', 'append', 'clear',
            'system', 'global', 'interface', 'admin', 'settings', 'ha', 'dns',
            'firewall', 'policy', 'address', 'addrgrp', 'service', 'custom',
            'schedule', 'recurring', 'onetime', 'ippool', 'vip', 'central-snat',
            'router', 'static', 'bgp', 'ospf', 'rip', 'multicast', 'policy-route',
            'vpn', 'ipsec', 'phase1-interface', 'phase2-interface', 'ssl',
            'ssl-web-portal', 'tunnel-mode', 'web-mode', 'certificate', 'local',
            'user', 'local', 'radius', 'ldap', 'group', 'peer', 'peergrp',
            'antivirus', 'profile', 'webfilter', 'ips', 'sensor', 'application',
            'list', 'control', 'emailfilter', 'dlp', 'filefilter', 'voip',
            'waf', 'profile', 'signature', 'protocol-options', 'ssh-filter',
            'log', 'fortianalyzer', 'forticloud', 'syslogd', 'memory', 'disk',
            'backup', 'restore', 'reboot', 'shutdown', 'factoryreset', 'revision',
            'debug', 'flow', 'trace', 'sniffer', 'packet', 'top', 'performance',
            'status', 'arp', 'session', 'route', 'neighbor', 'hardware', 'nic'
        ]

        # Linux - bash commands and common utilities
        linux = [
            'ls', 'cd', 'pwd', 'mkdir', 'rmdir', 'rm', 'cp', 'mv', 'touch', 'cat',
            'less', 'more', 'head', 'tail', 'grep', 'find', 'locate', 'which', 'whereis',
            'chmod', 'chown', 'chgrp', 'umask', 'ln', 'file', 'stat', 'du', 'df',
            'tar', 'gzip', 'gunzip', 'bzip2', 'bunzip2', 'zip', 'unzip', 'xz',
            'ps', 'top', 'htop', 'kill', 'killall', 'pkill', 'bg', 'fg', 'jobs',
            'systemctl', 'service', 'journalctl', 'dmesg', 'uname', 'hostname',
            'ifconfig', 'ip', 'route', 'netstat', 'ss', 'ping', 'traceroute', 'dig',
            'nslookup', 'host', 'curl', 'wget', 'ssh', 'scp', 'rsync', 'ftp', 'sftp',
            'apt', 'apt-get', 'dpkg', 'yum', 'dnf', 'rpm', 'pacman', 'zypper',
            'sudo', 'su', 'useradd', 'userdel', 'usermod', 'groupadd', 'groupdel',
            'passwd', 'who', 'w', 'last', 'id', 'groups', 'finger',
            'echo', 'printf', 'read', 'export', 'env', 'set', 'unset', 'alias',
            'history', 'source', 'exec', 'exit', 'logout', 'clear', 'reset',
            'man', 'info', 'help', 'apropos', 'whatis', 'type', 'command',
            'mount', 'umount', 'fdisk', 'mkfs', 'fsck', 'lsblk', 'blkid',
            'cron', 'crontab', 'at', 'batch', 'sleep', 'watch', 'time', 'date',
            'awk', 'sed', 'cut', 'sort', 'uniq', 'wc', 'tr', 'tee', 'xargs',
            'vim', 'nano', 'emacs', 'vi', 'gedit', 'pico',
            'make', 'gcc', 'g++', 'python', 'python3', 'perl', 'ruby', 'node',
            'git', 'svn', 'docker', 'kubectl', 'systemd', 'init', 'uptime', 'free'
        ]

        # Default - no highlighting (empty list)
        default = []

        vendor_keywords = {
            'Default': default,
            'Linux': linux,
            'Cisco': cisco,
            'Huawei': huawei,
            'H3C': h3c,
            'Juniper': juniper,
            'D-Link': dlink,
            'Brocade': brocade,
            'Datacom': datacom,
            'Fortinet': fortinet
        }

        return vendor_keywords.get(self.vendor, default)

    def insert_cursor_at_position(self, html_text, raw_text, cursor_pos):
        """Insert cursor highlight at specific position in HTML text"""
        import re

        # If cursor is beyond text length, add it at the end
        if cursor_pos >= len(raw_text):
            return html_text + '<span style="color: #0a0a0a; background-color: #e0e0e0;">█</span>'

        # Build a map of raw text positions to HTML positions
        # We need to find where in the HTML the cursor_pos character appears
        raw_idx = 0
        html_idx = 0
        in_tag = False

        while html_idx < len(html_text) and raw_idx < len(raw_text):
            if html_text[html_idx] == '<':
                in_tag = True
                html_idx += 1
            elif html_text[html_idx] == '>':
                in_tag = False
                html_idx += 1
            elif in_tag:
                html_idx += 1
            else:
                # Check for HTML entities
                if html_text[html_idx:html_idx+5] == '&amp;':
                    if raw_idx == cursor_pos:
                        # Insert cursor here
                        return (html_text[:html_idx] +
                               '<span style="color: #0a0a0a; background-color: #e0e0e0;">&amp;</span>' +
                               html_text[html_idx+5:])
                    raw_idx += 1
                    html_idx += 5
                elif html_text[html_idx:html_idx+4] == '&lt;':
                    if raw_idx == cursor_pos:
                        return (html_text[:html_idx] +
                               '<span style="color: #0a0a0a; background-color: #e0e0e0;">&lt;</span>' +
                               html_text[html_idx+4:])
                    raw_idx += 1
                    html_idx += 4
                elif html_text[html_idx:html_idx+4] == '&gt;':
                    if raw_idx == cursor_pos:
                        return (html_text[:html_idx] +
                               '<span style="color: #0a0a0a; background-color: #e0e0e0;">&gt;</span>' +
                               html_text[html_idx+4:])
                    raw_idx += 1
                    html_idx += 4
                else:
                    if raw_idx == cursor_pos:
                        # Insert cursor here
                        char = html_text[html_idx]
                        if char == ' ':
                            char = '&nbsp;'
                        return (html_text[:html_idx] +
                               f'<span style="color: #0a0a0a; background-color: #e0e0e0;">{char}</span>' +
                               html_text[html_idx+1:])
                    raw_idx += 1
                    html_idx += 1

        return html_text

    def apply_syntax_highlighting(self, text):
        """Apply syntax highlighting for network equipment commands"""
        import re

        # Don't highlight if text is empty or whitespace
        if not text.strip():
            return text

        # Escape HTML
        text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

        # Get keywords for selected vendor
        keywords = self.get_vendor_keywords()

        # Highlight keywords (cyan - vibrant)
        for keyword in keywords:
            # Match whole words only, case insensitive
            pattern = r'\b(' + re.escape(keyword) + r')\b'
            text = re.sub(pattern, r'<span style="color: #00ffff; font-weight: bold;">\1</span>', text, flags=re.IGNORECASE)

        # Highlight IP addresses (green - vibrant)
        ip_pattern = r'\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?:/\d{1,2})?)\b'
        text = re.sub(ip_pattern, r'<span style="color: #00ff00; font-weight: bold;">\1</span>', text)

        # Highlight MAC addresses (lime green - vibrant)
        mac_pattern = r'\b([0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}|[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2})\b'
        text = re.sub(mac_pattern, r'<span style="color: #00ff88; font-weight: bold;">\1</span>', text)

        # Highlight numbers (yellow - vibrant)
        # Avoid matching numbers already highlighted (in IP/MAC)
        number_pattern = r'(?<![\d\.])\b(\d+)\b(?![\d\.])'
        text = re.sub(number_pattern, r'<span style="color: #ffff00;">\1</span>', text)

        # Highlight prompts (magenta - vibrant) - patterns like [SWITCH]#, Router>, etc.
        prompt_pattern = r'^([\[\<]?[A-Za-z0-9_-]+[\]\>]?[#&gt;])'
        text = re.sub(prompt_pattern, r'<span style="color: #ff00ff; font-weight: bold;">\1</span>', text, flags=re.MULTILINE)

        return text

    def get_ansi_color(self, color, is_background=False):
        """Convert pyte color to HTML color code"""
        # ANSI color palette (standard 16 colors)
        ansi_colors = {
            'black': '#000000',
            'red': '#cd0000',
            'green': '#00cd00',
            'brown': '#cdcd00',
            'blue': '#0000ee',
            'magenta': '#cd00cd',
            'cyan': '#00cdcd',
            'white': '#e5e5e5',
            # Bright variants
            'brightblack': '#7f7f7f',
            'brightred': '#ff0000',
            'brightgreen': '#00ff00',
            'brightyellow': '#ffff00',
            'brightblue': '#5c5cff',
            'brightmagenta': '#ff00ff',
            'brightcyan': '#00ffff',
            'brightwhite': '#ffffff',
        }

        # Default colors
        default_fg = '#e0e0e0'
        default_bg = 'transparent'

        if color == 'default':
            return default_bg if is_background else default_fg

        # Named color
        if isinstance(color, str):
            return ansi_colors.get(color, default_bg if is_background else default_fg)

        # 256-color palette (simplified - using approximations)
        if isinstance(color, int):
            if color < 16:
                # Standard colors
                color_names = ['black', 'red', 'green', 'brown', 'blue', 'magenta', 'cyan', 'white',
                              'brightblack', 'brightred', 'brightgreen', 'brightyellow',
                              'brightblue', 'brightmagenta', 'brightcyan', 'brightwhite']
                return ansi_colors.get(color_names[color], default_bg if is_background else default_fg)
            elif color < 232:
                # 216 color cube (6x6x6)
                color -= 16
                r = (color // 36) * 51
                g = ((color % 36) // 6) * 51
                b = (color % 6) * 51
                return f'#{r:02x}{g:02x}{b:02x}'
            else:
                # Grayscale
                gray = 8 + (color - 232) * 10
                return f'#{gray:02x}{gray:02x}{gray:02x}'

        return default_bg if is_background else default_fg

    def _render_line(self, line_buffer, columns, cursor_x=None):
        """Render a single line (from screen buffer or history) to an HTML string.

        Args:
            line_buffer: dict-like mapping column index to pyte Char objects
            columns: number of columns to render
            cursor_x: if not None, draw cursor block at this column
        """
        raw_line = ""
        has_ansi_colors = False

        for x in range(columns):
            char = line_buffer[x]
            raw_line += char.data
            if char.fg != 'default' or char.bg != 'default' or char.bold or char.italics or char.underscore or char.reverse:
                has_ansi_colors = True

        if has_ansi_colors:
            line = ""
            x = 0
            while x < columns:
                char = line_buffer[x]

                fg_color = self.get_ansi_color(char.fg, is_background=False)
                bg_color = self.get_ansi_color(char.bg, is_background=True)

                styles = [f'color: {fg_color}']
                if bg_color != 'transparent':
                    styles.append(f'background-color: {bg_color}')
                if char.bold:
                    styles.append('font-weight: bold')
                if char.italics:
                    styles.append('font-style: italic')
                if char.underscore:
                    styles.append('text-decoration: underline')
                if char.reverse:
                    styles = [f'color: {bg_color if bg_color != "transparent" else "#0a0a0a"}',
                             f'background-color: {fg_color}']

                is_cursor = (cursor_x is not None and x == cursor_x)

                if is_cursor:
                    char_data = char.data
                    if char_data == ' ' or char_data == '':
                        char_data = '█'
                        styles = ['color: #e0e0e0', 'background-color: transparent']
                    else:
                        char_data = char_data.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                        styles = ['color: #0a0a0a', 'background-color: #e0e0e0']
                    style_str = '; '.join(styles)
                    line += f'<span style="{style_str}">{char_data}</span>'
                    x += 1
                else:
                    style_str = '; '.join(styles)
                    group_text = ""

                    while x < columns:
                        if cursor_x is not None and x == cursor_x:
                            break

                        next_char = line_buffer[x]
                        next_fg = self.get_ansi_color(next_char.fg, is_background=False)
                        next_bg = self.get_ansi_color(next_char.bg, is_background=True)

                        next_styles = [f'color: {next_fg}']
                        if next_bg != 'transparent':
                            next_styles.append(f'background-color: {next_bg}')
                        if next_char.bold:
                            next_styles.append('font-weight: bold')
                        if next_char.italics:
                            next_styles.append('font-style: italic')
                        if next_char.underscore:
                            next_styles.append('text-decoration: underline')
                        if next_char.reverse:
                            next_styles = [f'color: {next_bg if next_bg != "transparent" else "#0a0a0a"}',
                                         f'background-color: {next_fg}']

                        next_style_str = '; '.join(next_styles)

                        if next_style_str != style_str:
                            break

                        char_text = next_char.data.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                        if char_text == ' ':
                            char_text = '&nbsp;'
                        group_text += char_text
                        x += 1

                    if group_text:
                        line += f'<span style="{style_str}">{group_text}</span>'
            return line
        else:
            highlighted_line = self.apply_syntax_highlighting(raw_line)
            if cursor_x is not None:
                highlighted_line = self.insert_cursor_at_position(highlighted_line, raw_line, cursor_x)
            return highlighted_line

    def render_screen(self):
        """Render pyte screen buffer to QTextEdit with ANSI color support and syntax highlighting"""
        # Don't update if user is selecting text or mouse is pressed
        if self.textCursor().hasSelection() or self.mouse_pressed:
            return

        # Always drain history lines into scrollback buffer (even in scrollback mode)
        while self.screen.history.top:
            history_line = self.screen.history.top.popleft()
            rendered = self._render_line(history_line, self.screen.columns)
            self._scrollback_lines.append(rendered)
            self._scrollback_dirty = True
            self._render_needed = True

        # Trim scrollback if it exceeds max
        if len(self._scrollback_lines) > self._max_scrollback:
            self._scrollback_lines = self._scrollback_lines[-self._max_scrollback:]
            self._scrollback_dirty = True

        # Rebuild scrollback cache if needed
        if self._scrollback_dirty:
            self._scrollback_cache = '\n'.join(self._scrollback_lines)
            self._scrollback_dirty = False

        # In scrollback mode: check if user scrolled back to bottom to exit
        if self._in_scrollback_mode:
            scrollbar = self.verticalScrollBar()
            if scrollbar.maximum() - scrollbar.value() <= 10:
                self._in_scrollback_mode = False
                self._render_needed = True
            else:
                return  # Frozen while browsing history

        # Nothing changed since last render — skip setHtml entirely
        if not self._render_needed:
            return
        self._render_needed = False

        # Render ONLY the current screen (no scrollback — keeps the HTML small and setHtml fast)
        cursor_x = self.screen.cursor.x
        cursor_y = self.screen.cursor.y
        screen_lines = []
        for y in range(self.screen.lines):
            cx = cursor_x if y == cursor_y else None
            screen_lines.append(self._render_line(self.screen.buffer[y], self.screen.columns, cursor_x=cx))

        pre_open = '<pre style="margin: 0; padding: 0; line-height: 1.2; user-select: text; -webkit-user-select: text;">'
        new_html = pre_open + '\n'.join(screen_lines) + '</pre>'

        self.setUpdatesEnabled(False)
        self.setHtml(new_html)
        cursor = self.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.setTextCursor(cursor)
        scrollbar = self.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
        self.setUpdatesEnabled(True)

    def resizeEvent(self, event):
        """Recalculate terminal dimensions when widget is resized"""
        super().resizeEvent(event)
        # Skip resize recalculation when updates are disabled (triggered by setHtml)
        if not self.updatesEnabled():
            return
        self._recalculate_size()

    def _recalculate_size(self):
        """Calculate columns and lines from widget size and font metrics, then resize pyte screen"""
        from PyQt6.QtGui import QFontMetricsF
        fm = QFontMetricsF(self.font())
        char_width = fm.averageCharWidth()
        char_height = fm.height()
        if char_width <= 0 or char_height <= 0:
            return
        # Account for padding (10px on each side from stylesheet)
        viewport = self.viewport()
        available_width = viewport.width() - 20
        available_height = viewport.height()
        cols = max(40, int(available_width / char_width))
        rows = max(10, int(available_height / char_height))
        if cols != self.screen.columns or rows != self.screen.lines:
            self.screen.resize(rows, cols)
            self._render_needed = True
            self.size_changed.emit(cols, rows)

    def increase_font_size(self):
        """Increase terminal font size"""
        if self.font_size < 24:  # Maximum font size limit
            self.font_size += 1
            self.setFont(QFont("Monospace", self.font_size))
            self._recalculate_size()

    def decrease_font_size(self):
        """Decrease terminal font size"""
        if self.font_size > 6:  # Minimum font size limit
            self.font_size -= 1
            self.setFont(QFont("Monospace", self.font_size))
            self._recalculate_size()


class ConnectionWorker(QThread):
    """Worker thread for establishing SSH/Telnet connections without blocking UI"""
    
    connection_ready = pyqtSignal(str, object, object, object)  # type, client, channel/None, host_info
    connection_failed = pyqtSignal(str)  # Emits error message on failure
    
    def __init__(self, connection_type, host, port, username, password=None, key_path=None):
        super().__init__()
        self.connection_type = connection_type  # 'ssh' or 'telnet'
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.key_path = key_path
    
    def run(self):
        """Execute connection in background thread"""
        try:
            if self.connection_type == 'telnet':
                # Establish Telnet connection
                import telnetlib
                telnet_client = telnetlib.Telnet(self.host, int(self.port), timeout=10)
                self.connection_ready.emit('telnet', telnet_client, None, 
                                          (self.host, self.port, self.username))
            else:  # SSH
                # Establish SSH connection
                if not SSH_AVAILABLE:
                    self.connection_failed.emit("paramiko library is not installed")
                    return
                
                import paramiko
                ssh_client = paramiko.SSHClient()
                ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                
                # Connect with password or key
                if self.key_path:
                    ssh_client.connect(
                        self.host, int(self.port), self.username,
                        key_filename=self.key_path, timeout=10
                    )
                else:
                    ssh_client.connect(
                        self.host, int(self.port), self.username,
                        password=self.password, timeout=10
                    )
                
                # Open interactive shell
                channel = ssh_client.invoke_shell()
                channel.settimeout(0.1)
                
                self.connection_ready.emit('ssh', ssh_client, channel,
                                          (self.host, self.port, self.username))
        except Exception as e:
            self.connection_failed.emit(str(e))


class TerminalDialog(QDialog):
    """Dialog window containing the embedded terminal"""

    # Signal for thread-safe terminal output
    ssh_output_received = pyqtSignal(str)

    def __init__(self, parent=None, config=None):
        super().__init__(parent)
        self.setWindowTitle("SerialCom Terminal")
        self.setMinimumSize(1200, 700)
        self.process = None
        self.sudo_process = None
        self.config = config
        # SSH-related attributes
        self.ssh_client = None
        self.ssh_channel = None
        self.ssh_read_thread = None
        self.ssh_running = False
        # Telnet-related attributes
        self.telnet_client = None
        self.telnet_read_thread = None
        self.telnet_running = False
        self.connection_type = 'serial'

        self.init_ui()

        # Connect SSH output signal to terminal
        self.ssh_output_received.connect(self._on_ssh_output)

    def get_icon_path(self, icon_name, subdir='icons'):
        """Get the path to an icon for different installation types"""
        # Check for Flatpak
        flatpak_path = f'/app/share/io.github.benjamimgois.serialcom/{subdir}/{icon_name}'
        if os.path.exists(flatpak_path):
            return flatpak_path
        # Check for AppImage
        if os.environ.get('APPDIR'):
            appdir = os.environ.get('APPDIR')
            appimage_path = os.path.join(appdir, f'usr/share/serialcom/{subdir}/{icon_name}')
            if os.path.exists(appimage_path):
                return appimage_path
        # Local installation or development
        # Try assets/subdir directory
        assets_path = os.path.join(os.path.dirname(__file__), f'assets/{subdir}/{icon_name}')
        if os.path.exists(assets_path):
            return assets_path
        # Try root directory (legacy)
        root_path = os.path.join(os.path.dirname(__file__), icon_name)
        if os.path.exists(root_path):
            return root_path
        return None

    def get_arrow_icon_path(self):
        """Get the path to arrow_down.svg"""
        return self.get_icon_path('arrow_down.svg') or ''

    def get_vendor_icon_path(self, vendor):
        """Get the path to vendor icon SVG"""
        vendor_file = vendor.lower().replace('-', '').replace(' ', '') + '.svg'
        path = self.get_icon_path(vendor_file, 'vendors')
        if path:
            return path
        # Fallback to generic
        return self.get_icon_path('generic.svg', 'vendors') or ''

    BANNER_COLORS = [
        "#4caf50",  # green
        "#2196F3",  # blue
        "#ff9800",  # orange
        "#9c27b0",  # purple
        "#e91e63",  # pink
        "#00bcd4",  # cyan
        "#ff5722",  # deep orange
        "#3f51b5",  # indigo
    ]
    _banner_index = 0

    def set_profile_name(self, name):
        """Show the profile name banner at the top of the terminal"""
        if name:
            color = self.BANNER_COLORS[TerminalDialog._banner_index % len(self.BANNER_COLORS)]
            TerminalDialog._banner_index += 1
            self.profile_label.setText(f"  {name}")
            self.profile_label.setStyleSheet(f"""
                QLabel {{
                    background-color: {color};
                    color: #ffffff;
                    font-size: 11pt;
                    font-weight: bold;
                    padding: 4px 10px;
                }}
            """)
            self.profile_label.setVisible(True)

    def init_ui(self):
        """Initialize the terminal dialog UI"""
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Profile name banner (hidden by default)
        self.profile_label = QLabel()
        self.profile_label.setVisible(False)
        layout.addWidget(self.profile_label)

        # Terminal widget
        self.terminal = TerminalWidget()
        self.terminal.send_input.connect(self.send_to_process)
        self.terminal.size_changed.connect(self._on_terminal_resized)
        self.terminal.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        layout.addWidget(self.terminal, 1)
        
        # Control buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(10, 5, 10, 10)

        # Font size buttons
        self.font_decrease_btn = QPushButton("A-")
        self.font_decrease_btn.setAutoDefault(False)
        self.font_decrease_btn.setMinimumHeight(35)
        self.font_decrease_btn.setMaximumWidth(50)
        self.font_decrease_btn.setFont(QFont("Sans Serif", 10, QFont.Weight.Bold))
        self.font_decrease_btn.clicked.connect(self.terminal.decrease_font_size)
        self.font_decrease_btn.setStyleSheet("""
            QPushButton {
                background-color: #89b4fa;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #74a0e8;
            }
            QPushButton:pressed {
                background-color: #5f8cd6;
            }
        """)

        self.font_increase_btn = QPushButton("A+")
        self.font_increase_btn.setAutoDefault(False)
        self.font_increase_btn.setMinimumHeight(35)
        self.font_increase_btn.setMaximumWidth(50)
        self.font_increase_btn.setFont(QFont("Sans Serif", 10, QFont.Weight.Bold))
        self.font_increase_btn.clicked.connect(self.terminal.increase_font_size)
        self.font_increase_btn.setStyleSheet("""
            QPushButton {
                background-color: #89b4fa;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #74a0e8;
            }
            QPushButton:pressed {
                background-color: #5f8cd6;
            }
        """)

        self.disconnect_btn = QPushButton("DISCONNECT")
        self.disconnect_btn.setAutoDefault(False)
        self.disconnect_btn.setMinimumHeight(35)
        self.disconnect_btn.setFont(QFont("Sans Serif", 10, QFont.Weight.Bold))
        self.disconnect_btn.clicked.connect(self.disconnect)
        self.disconnect_btn.setStyleSheet("""
            QPushButton {
                background-color: #f38ba8;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #f26d8f;
            }
            QPushButton:pressed {
                background-color: #d95a7a;
            }
        """)

        # Vendor selector
        # Get arrow icon path (same method as main window)
        arrow_path = self.get_arrow_icon_path()

        self.vendor_combo = QComboBox()
        self.vendor_combo.setPlaceholderText("Manufacturer syntax highlight")
        self.vendor_combo.addItems(['Default', 'Linux', 'Cisco', 'Huawei', 'H3C', 'Juniper', 'D-Link', 'Brocade', 'Datacom', 'Fortinet'])

        # Load saved vendor selection
        if self.config:
            saved_vendor = self.config.get('vendor')
            index = self.vendor_combo.findText(saved_vendor)
            if index >= 0:
                self.vendor_combo.setCurrentIndex(index)
        else:
            self.vendor_combo.setCurrentText('Default')

        self.vendor_combo.currentTextChanged.connect(self.change_vendor)
        self.vendor_combo.setMinimumHeight(35)
        self.vendor_combo.setMaximumWidth(130)
        self.vendor_combo.setStyleSheet(f"""
            QComboBox {{
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 2px solid #5a5a5a;
                border-radius: 6px;
                padding: 5px 28px 5px 10px;
                font-size: 10pt;
            }}
            QComboBox:hover {{
                border: 2px solid #707070;
                background-color: #454545;
            }}
            QComboBox:focus {{
                border: 2px solid #707070;
            }}
            QComboBox::drop-down {{
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 25px;
                border-left: 1px solid #5a5a5a;
                border-top-right-radius: 5px;
                border-bottom-right-radius: 5px;
                background-color: transparent;
            }}
            QComboBox::down-arrow {{
                image: url({arrow_path});
                width: 12px;
                height: 12px;
            }}
            QComboBox QAbstractItemView {{
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 2px solid #5a5a5a;
                selection-background-color: #5a5a5a;
                selection-color: #ffffff;
                outline: none;
                padding: 4px;
            }}
            QComboBox QAbstractItemView::item {{
                min-height: 28px;
                padding: 5px;
            }}
            QComboBox QAbstractItemView::item:hover {{
                background-color: #4a4a4a;
            }}
        """)

        # Vendor icon label
        self.vendor_icon = QLabel()
        self.vendor_icon.setFixedSize(36, 36)
        self.vendor_icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.vendor_icon.setToolTip("Equipment vendor")
        # Load initial vendor icon
        initial_vendor = self.vendor_combo.currentText()
        self.update_vendor_icon(initial_vendor)

        button_layout.addWidget(self.font_decrease_btn)
        button_layout.addSpacing(10)  # Add space between font buttons
        button_layout.addWidget(self.font_increase_btn)
        button_layout.addSpacing(20)  # Add space before vendor selector
        button_layout.addWidget(self.vendor_combo)
        button_layout.addSpacing(8)
        button_layout.addWidget(self.vendor_icon)
        button_layout.addStretch()

        # Search widgets (centered)
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search...")
        self.search_input.setMinimumHeight(35)
        self.search_input.setMaximumWidth(200)
        self.search_input.setStyleSheet("""
            QLineEdit {
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 1px solid #5a5a5a;
                border-radius: 6px;
                padding: 4px 8px;
                font-size: 10pt;
            }
            QLineEdit:focus {
                border: 1px solid #707070;
            }
        """)
        self.search_input.textChanged.connect(self._on_search_changed)
        self.search_input.returnPressed.connect(self._search_next)

        search_nav_style = """
            QPushButton {
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 1px solid #5a5a5a;
                border-radius: 4px;
                font-size: 10pt;
            }
            QPushButton:hover {
                background-color: #454545;
            }
        """

        self.search_prev_btn = QPushButton("▲")
        self.search_prev_btn.setAutoDefault(False)
        self.search_prev_btn.setFixedSize(30, 35)
        self.search_prev_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.search_prev_btn.setStyleSheet(search_nav_style)
        self.search_prev_btn.clicked.connect(self._search_prev)

        self.search_next_btn = QPushButton("▼")
        self.search_next_btn.setAutoDefault(False)
        self.search_next_btn.setFixedSize(30, 35)
        self.search_next_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.search_next_btn.setStyleSheet(search_nav_style)
        self.search_next_btn.clicked.connect(self._search_next)

        self.search_status = QLabel()
        self.search_status.setStyleSheet("color: #b0b0b0; font-size: 9pt;")

        button_layout.addWidget(self.search_input)
        button_layout.addWidget(self.search_prev_btn)
        button_layout.addWidget(self.search_next_btn)
        button_layout.addWidget(self.search_status)

        button_layout.addStretch()
        button_layout.addWidget(self.disconnect_btn)

        layout.addLayout(button_layout)
        self.setLayout(layout)

    def keyPressEvent(self, event):
        """Handle Ctrl+F to focus search input"""
        if event.key() == Qt.Key.Key_F and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            self.search_input.setFocus()
            self.search_input.selectAll()
        elif event.key() == Qt.Key.Key_Escape and self.search_input.hasFocus():
            self.search_input.clear()
            self.search_status.clear()
            self._search_matches = []
            self.terminal.setExtraSelections([])
            self.terminal.setFocus()
        else:
            super().keyPressEvent(event)

    def _on_search_changed(self, text):
        """Live search as the user types"""
        self._search_matches = []
        self._search_match_idx = -1
        if not text:
            self.search_status.clear()
            self.terminal.setExtraSelections([])
            return
        lines = self._get_terminal_lines()
        matches = []
        lower_query = text.lower()
        for i, line in enumerate(lines):
            idx = 0
            lower_line = line.lower()
            while True:
                pos = lower_line.find(lower_query, idx)
                if pos == -1:
                    break
                matches.append((i, pos))
                idx = pos + 1
        self._search_matches = matches
        if not matches:
            self.search_status.setText("No results")
            return
        self._search_match_idx = 0
        self._show_search_result()

    def _get_terminal_lines(self):
        """Get all terminal lines (scrollback + current screen) as plain text list"""
        import re
        tag_re = re.compile(r'<[^>]+>')
        lines = []
        for html_line in self.terminal._scrollback_lines:
            plain = tag_re.sub('', html_line)
            plain = plain.replace('&amp;', '&').replace('&lt;', '<').replace('&gt;', '>').replace('&nbsp;', ' ')
            lines.append(plain)
        for y in range(self.terminal.screen.lines):
            row = self.terminal.screen.buffer[y]
            line = ''.join(row[x].data for x in range(self.terminal.screen.columns)).rstrip()
            lines.append(line)
        return lines

    def _search_next(self):
        """Navigate to next search match"""
        if not getattr(self, '_search_matches', None):
            return
        self._search_match_idx = (self._search_match_idx + 1) % len(self._search_matches)
        self._show_search_result()

    def _search_prev(self):
        """Navigate to previous search match"""
        if not getattr(self, '_search_matches', None):
            return
        self._search_match_idx = (self._search_match_idx - 1) % len(self._search_matches)
        self._show_search_result()

    def _show_search_result(self):
        """Scroll to and highlight all search matches using ExtraSelections"""
        matches = self._search_matches
        idx = self._search_match_idx
        self.search_status.setText(f"{idx + 1}/{len(matches)}")

        query = self.search_input.text()
        query_len = len(query)

        # Build ExtraSelections for all matches
        selections = []
        current_sel = None
        for i, (line_num, col) in enumerate(matches):
            cursor = self.terminal.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.Start)
            for _ in range(line_num):
                cursor.movePosition(QTextCursor.MoveOperation.Down)
            cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)
            for _ in range(col):
                cursor.movePosition(QTextCursor.MoveOperation.Right)
            cursor.movePosition(QTextCursor.MoveOperation.Right, QTextCursor.MoveMode.KeepAnchor, query_len)

            sel = QTextEdit.ExtraSelection()
            fmt = QTextCharFormat()
            if i == idx:
                # Current match: bright orange
                fmt.setBackground(QColor("#ff9800"))
                fmt.setForeground(QColor("#000000"))
                current_sel = cursor
            else:
                # Other matches: yellow
                fmt.setBackground(QColor("#ffeb3b"))
                fmt.setForeground(QColor("#000000"))
            sel.format = fmt
            sel.cursor = cursor
            selections.append(sel)

        self.terminal.setExtraSelections(selections)

        # Scroll to current match
        if current_sel:
            self.terminal.setTextCursor(current_sel)
            self.terminal.ensureCursorVisible()
            # Clear cursor selection so blue highlight doesn't show
            clear = self.terminal.textCursor()
            clear.clearSelection()
            self.terminal.setTextCursor(clear)

    def update_vendor_icon(self, vendor):
        """Update the vendor icon QLabel with the appropriate SVG"""
        icon_path = self.get_vendor_icon_path(vendor)
        pixmap = QPixmap(icon_path)
        if not pixmap.isNull():
            # Scale pixmap to fit the label
            scaled_pixmap = pixmap.scaled(32, 32, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
            self.vendor_icon.setPixmap(scaled_pixmap)
        else:
            # Fallback to generic icon if loading fails
            fallback_path = self.get_vendor_icon_path('Default')
            fallback_pixmap = QPixmap(fallback_path)
            if not fallback_pixmap.isNull():
                scaled_pixmap = fallback_pixmap.scaled(32, 32, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                self.vendor_icon.setPixmap(scaled_pixmap)

    def change_vendor(self, vendor):
        """Change the syntax highlighting vendor"""
        self.terminal.set_vendor(vendor)

        # Update vendor icon based on selection
        self.update_vendor_icon(vendor)

        # Save vendor selection
        if self.config:
            self.config.set('vendor', vendor)

    def start_picocom(self, cmd):
        """Start picocom process with sudo"""
        # Ask for sudo password using styled dialog
        password_dialog = QDialog(self)
        password_dialog.setWindowTitle("Sudo Password Required")
        password_dialog.setModal(True)
        password_dialog.setFixedSize(420, 160)
        password_dialog.setStyleSheet("""
            QDialog { background-color: #1e1e2e; }
            QLabel { color: #cdd6f4; font-size: 10pt; }
            QLineEdit {
                background-color: #313244; color: #cdd6f4;
                border: 1px solid #585b70; border-radius: 6px;
                padding: 8px; font-size: 10pt;
            }
            QLineEdit:focus { border: 2px solid #89b4fa; }
            QPushButton {
                background-color: #89b4fa; color: #1e1e2e;
                border: none; border-radius: 6px;
                padding: 8px 16px; font-weight: bold; min-width: 80px;
            }
            QPushButton:hover { background-color: #74c7ec; }
            QPushButton#cancelButton { background-color: #585b70; color: #cdd6f4; }
            QPushButton#cancelButton:hover { background-color: #6c7086; }
        """)
        dlg_layout = QVBoxLayout()
        dlg_layout.addWidget(QLabel("Please enter your sudo password to access serial port:"))
        password_input = QLineEdit()
        password_input.setEchoMode(QLineEdit.EchoMode.Password)
        dlg_layout.addWidget(password_input)
        btn_layout = QHBoxLayout()
        ok_button = QPushButton("OK")
        ok_button.clicked.connect(password_dialog.accept)
        cancel_button = QPushButton("Cancel")
        cancel_button.setObjectName("cancelButton")
        cancel_button.clicked.connect(password_dialog.reject)
        btn_layout.addStretch()
        btn_layout.addWidget(ok_button)
        btn_layout.addWidget(cancel_button)
        dlg_layout.addLayout(btn_layout)
        password_dialog.setLayout(dlg_layout)

        if password_dialog.exec() != QDialog.DialogCode.Accepted:
            self.terminal.append_output("[CANCELLED] Password not provided\n")
            return False
        password = password_input.text()
        if not password:
            self.terminal.append_output("[CANCELLED] Password not provided\n")
            return False

        # Create the process
        self.process = QProcess(self)
        self.process.readyReadStandardOutput.connect(self.handle_stdout)
        self.process.readyReadStandardError.connect(self.handle_stderr)
        self.process.finished.connect(self.process_finished)

        # Build sudo command
        picocom_cmd = ' '.join(cmd)
        full_cmd = ['sudo', '-S'] + cmd

        # Start process
        self.terminal.append_output(f"Starting: {picocom_cmd}\n")

        self.process.start(full_cmd[0], full_cmd[1:])

        if not self.process.waitForStarted(3000):
            self.terminal.append_output("\n[ERROR] Failed to start picocom\n")
            return False

        # Send password to sudo
        self.process.write((password + '\n').encode())
        password = None  # Clear password from memory

        self.terminal.append_output("Connecting...\n\n")

        return True

    def start_debug_mode(self):
        """Start terminal in debug mode with simulated Cisco router output"""
        self.setWindowTitle("SerialCom Terminal [DEBUG MODE]")

        # Simulated Cisco router configuration
        cisco_output = """\r
\r
Router>\x1b[33menable\x1b[0m\r
Password: \r
Router#\x1b[33mshow running-config\x1b[0m\r
Building configuration...\r
\r
Current configuration : 1584 bytes\r
!\r
! Last configuration change at 14:32:15 UTC Mon Jan 15 2024\r
!\r
version 15.1\r
service timestamps debug datetime msec\r
service timestamps log datetime msec\r
no service password-encryption\r
!\r
hostname \x1b[36mRouter\x1b[0m\r
!\r
boot-start-marker\r
boot-end-marker\r
!\r
enable secret 5 $1$mERr$hx5rVt7rPNoS4wqbXKX7m0\r
!\r
no aaa new-model\r
!\r
interface \x1b[36mGigabitEthernet0/0\x1b[0m\r
 description \x1b[32mWAN Connection to ISP\x1b[0m\r
 ip address \x1b[33m203.0.113.1\x1b[0m \x1b[33m255.255.255.252\x1b[0m\r
 duplex auto\r
 speed auto\r
!\r
interface \x1b[36mGigabitEthernet0/1\x1b[0m\r
 description \x1b[32mLAN Network\x1b[0m\r
 ip address \x1b[33m192.168.1.1\x1b[0m \x1b[33m255.255.255.0\x1b[0m\r
 duplex auto\r
 speed auto\r
!\r
interface \x1b[36mGigabitEthernet0/2\x1b[0m\r
 description \x1b[32mDMZ Network\x1b[0m\r
 ip address \x1b[33m10.0.0.1\x1b[0m \x1b[33m255.255.255.0\x1b[0m\r
 duplex auto\r
 speed auto\r
!\r
ip route \x1b[33m0.0.0.0\x1b[0m \x1b[33m0.0.0.0\x1b[0m \x1b[33m203.0.113.2\x1b[0m\r
!\r
ip access-list extended \x1b[36mINBOUND_ACL\x1b[0m\r
 \x1b[32mpermit\x1b[0m tcp any any eq \x1b[33m22\x1b[0m\r
 \x1b[32mpermit\x1b[0m tcp any any eq \x1b[33m80\x1b[0m\r
 \x1b[32mpermit\x1b[0m tcp any any eq \x1b[33m443\x1b[0m\r
 \x1b[31mdeny\x1b[0m ip any any log\r
!\r
line con 0\r
 logging synchronous\r
line aux 0\r
line vty 0 4\r
 login local\r
 transport input ssh\r
!\r
end\r
\r
Router#\x1b[33mshow ip interface brief\x1b[0m\r
Interface              IP-Address      OK? Method Status                Protocol\r
GigabitEthernet0/0     \x1b[33m203.0.113.1\x1b[0m     YES NVRAM  \x1b[32mup\x1b[0m                    \x1b[32mup\x1b[0m\r
GigabitEthernet0/1     \x1b[33m192.168.1.1\x1b[0m     YES NVRAM  \x1b[32mup\x1b[0m                    \x1b[32mup\x1b[0m\r
GigabitEthernet0/2     \x1b[33m10.0.0.1\x1b[0m        YES NVRAM  \x1b[32mup\x1b[0m                    \x1b[32mup\x1b[0m\r
\r
Router#\x1b[33mshow version\x1b[0m\r
Cisco IOS Software, C2900 Software (C2900-UNIVERSALK9-M), Version 15.1(4)M4\r
Technical Support: http://www.cisco.com/techsupport\r
Copyright (c) 1986-2012 by Cisco Systems, Inc.\r
\r
ROM: System Bootstrap, Version 15.0(1r)M9\r
\r
Router uptime is \x1b[33m2 days, 14 hours, 32 minutes\x1b[0m\r
System returned to ROM by power-on\r
System image file is "flash:c2900-universalk9-mz.SPA.151-4.M4.bin"\r
\r
Cisco CISCO2911/K9 (revision 1.0) with \x1b[33m512000K/62464K\x1b[0m bytes of memory.\r
Processor board ID FTX1524A0WZ\r
3 Gigabit Ethernet interfaces\r
DRAM configuration is 64 bits wide with parity disabled.\r
256K bytes of non-volatile configuration memory.\r
\r
Router#_\r
"""

        # Feed the simulated output to the terminal
        self.terminal.append_output(cisco_output)

    def send_to_process(self, text):
        """Send input to the active connection (picocom, SSH, or Telnet)"""
        if self.connection_type == 'ssh':
            self.send_to_ssh(text)
        elif self.connection_type == 'telnet':
            self.send_to_telnet(text)
        elif self.process and self.process.state() == QProcess.ProcessState.Running:
            self.process.write(text.encode())

    def start_ssh(self, host, port, username, password=None, key_path=None):
        """Start SSH connection using paramiko"""
        if not SSH_AVAILABLE:
            self.terminal.append_output("[ERROR] paramiko library not installed\n")
            self.terminal.append_output("Install with: pip install paramiko\n")
            return False

        self.connection_type = 'ssh'
        self.setWindowTitle(f"SerialCom Terminal - SSH: {username}@{host}")

        try:
            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            self.terminal.append_output(f"Connecting to {host}:{port}...\n")

            if key_path:
                # Key-based authentication
                key = paramiko.RSAKey.from_private_key_file(key_path)
                self.ssh_client.connect(host, port=int(port), username=username, pkey=key)
            else:
                # Password authentication
                self.ssh_client.connect(host, port=int(port), username=username, password=password)

            # Request a pseudo-terminal with actual widget dimensions
            cols = self.terminal.screen.columns
            rows = self.terminal.screen.lines
            self.ssh_channel = self.ssh_client.invoke_shell(term='xterm-256color', width=cols, height=rows)
            self.ssh_channel.settimeout(0.1)
            self.ssh_running = True

            # Start read thread
            self.ssh_read_thread = threading.Thread(target=self._ssh_read_loop, daemon=True)
            self.ssh_read_thread.start()

            self.terminal.append_output(f"Connected to {host}\n\n")
            # Ensure terminal has focus for keyboard input
            self.terminal.setFocus()
            return True

        except paramiko.AuthenticationException:
            self.terminal.append_output("[ERROR] Authentication failed\n")
            return False
        except paramiko.SSHException as e:
            self.terminal.append_output(f"[ERROR] SSH error: {e}\n")
            return False
        except Exception as e:
            self.terminal.append_output(f"[ERROR] Connection failed: {e}\n")
            return False

    def _ssh_read_loop(self):
        """Background thread to read SSH output"""
        import time
        print("[DEBUG] SSH read thread started")
        while self.ssh_running and self.ssh_channel:
            try:
                if self.ssh_channel.recv_ready():
                    data = self.ssh_channel.recv(4096)
                    if data:
                        text = data.decode('utf-8', errors='replace')
                        print(f"[DEBUG] Received {len(data)} bytes")
                        # Use signal for thread-safe UI update
                        self.ssh_output_received.emit(text)
                else:
                    # Small sleep to prevent CPU spinning
                    time.sleep(0.05)
            except socket.timeout:
                continue
            except Exception as e:
                print(f"[DEBUG] SSH read error: {e}")
                if self.ssh_running:
                    self.ssh_output_received.emit(f"\n[SSH Error: {e}]\n")
                break
        print("[DEBUG] SSH read thread ended")

    def _on_ssh_output(self, text):
        """Slot to handle SSH output in main thread"""
        print(f"[DEBUG] _on_ssh_output called with {len(text)} chars")
        self.terminal.append_output(text)

    def send_to_ssh(self, text):
        """Send input to SSH channel"""
        if self.ssh_channel and self.ssh_running:
            try:
                print(f"[DEBUG] Sending: {repr(text)}")
                self.ssh_channel.send(text.encode('utf-8'))
            except Exception as e:
                print(f"[DEBUG] Send error: {e}")
                self.terminal.append_output(f"\n[Send error: {e}]\n")
        else:
            print(f"[DEBUG] Cannot send - channel: {self.ssh_channel}, running: {self.ssh_running}")

    def _on_terminal_resized(self, cols, rows):
        """Notify the remote PTY about the new terminal size"""
        if self.ssh_channel and self.ssh_running:
            try:
                self.ssh_channel.resize_pty(width=cols, height=rows)
            except Exception:
                pass
        if self.telnet_client and self.telnet_running:
            try:
                # Send Telnet NAWS (Negotiate About Window Size)
                import struct
                naws = struct.pack('!HH', cols, rows)
                self.telnet_client.get_socket().sendall(
                    b'\xff\xfa\x1f' + naws + b'\xff\xf0'
                )
            except Exception:
                pass

    def disconnect_ssh(self):
        """Disconnect SSH session"""
        self.ssh_running = False
        if self.ssh_channel:
            try:
                self.ssh_channel.close()
            except:
                pass
            self.ssh_channel = None
        if self.ssh_client:
            try:
                self.ssh_client.close()
            except:
                pass
            self.ssh_client = None

    def start_telnet(self, host, port, username=None):
        """Start Telnet connection"""
        self.connection_type = 'telnet'
        self.setWindowTitle(f"SerialCom Terminal - Telnet: {host}")

        try:
            self.terminal.append_output(f"Connecting to {host}:{port}...\n")
            self.telnet_client = telnetlib.Telnet(host, int(port), timeout=10)
            self.telnet_running = True

            # Start read thread
            self.telnet_read_thread = threading.Thread(target=self._telnet_read_loop, daemon=True)
            self.telnet_read_thread.start()

            self.terminal.append_output(f"Connected to {host}\n\n")
            # Ensure terminal has focus for keyboard input
            self.terminal.setFocus()
            return True

        except Exception as e:
            self.terminal.append_output(f"[ERROR] Connection failed: {e}\n")
            return False

    def _telnet_read_loop(self):
        """Background thread to read Telnet output"""
        import time
        print("[DEBUG] Telnet read thread started")
        while self.telnet_running and self.telnet_client:
            try:
                data = self.telnet_client.read_very_eager()
                if data:
                    text = data.decode('utf-8', errors='replace')
                    print(f"[DEBUG] Received {len(data)} bytes")
                    # Use signal for thread-safe UI update
                    self.ssh_output_received.emit(text)
                else:
                    # Small sleep to prevent CPU spinning
                    time.sleep(0.05)
            except EOFError:
                print("[DEBUG] Telnet connection closed")
                if self.telnet_running:
                    self.ssh_output_received.emit("\n[Connection closed by remote host]\n")
                break
            except Exception as e:
                print(f"[DEBUG] Telnet read error: {e}")
                if self.telnet_running:
                    self.ssh_output_received.emit(f"\n[Telnet Error: {e}]\n")
                break
        print("[DEBUG] Telnet read thread ended")

    def send_to_telnet(self, text):
        """Send input to Telnet connection"""
        if self.telnet_client and self.telnet_running:
            try:
                print(f"[DEBUG] Sending: {repr(text)}")
                self.telnet_client.write(text.encode('utf-8'))
            except Exception as e:
                print(f"[DEBUG] Send error: {e}")
                self.terminal.append_output(f"\n[Send error: {e}]\n")
        else:
            print(f"[DEBUG] Cannot send - client: {self.telnet_client}, running: {self.telnet_running}")

    def disconnect_telnet(self):
        """Disconnect Telnet session"""
        self.telnet_running = False
        if self.telnet_client:
            try:
                self.telnet_client.close()
            except:
                pass
            self.telnet_client = None
    
    def handle_stdout(self):
        """Handle standard output from picocom"""
        if self.process:
            data = self.process.readAllStandardOutput()
            text = bytes(data).decode('utf-8', errors='replace')
            self.terminal.append_output(text)
    
    def handle_stderr(self):
        """Handle standard error from picocom"""
        if self.process:
            data = self.process.readAllStandardError()
            text = bytes(data).decode('utf-8', errors='replace')
            self.terminal.append_output(text)
    
    def process_finished(self, exit_code, exit_status):
        """Handle process termination"""
        self.terminal.append_output(f"\n\n[Process terminated with exit code {exit_code}]\n")
        self.terminal.append_output("You can close this window.\n")
        self.disconnect_btn.setText("CLOSE")
    
    def disconnect(self):
        """Disconnect from serial port, SSH, or Telnet"""
        if self.connection_type == 'ssh':
            self.disconnect_ssh()
        elif self.connection_type == 'telnet':
            self.disconnect_telnet()
        elif self.process and self.process.state() == QProcess.ProcessState.Running:
            # Send Ctrl+A Ctrl+X to exit picocom gracefully
            self.process.write(b'\x01\x18')

            # Wait a bit for graceful exit
            if not self.process.waitForFinished(2000):
                # Force terminate if needed
                self.process.terminate()
                if not self.process.waitForFinished(1000):
                    self.process.kill()

        self.close()
    
    def closeEvent(self, event):
        """Handle window close event"""
        is_connected = False
        if self.connection_type == 'ssh':
            is_connected = self.ssh_running
        elif self.connection_type == 'telnet':
            is_connected = self.telnet_running
        elif self.process:
            is_connected = self.process.state() == QProcess.ProcessState.Running

        if is_connected:
            reply = QMessageBox.question(
                self,
                'Confirm Exit',
                'Connection is still active. Disconnect and close?',
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                self.disconnect()
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()


class SerialTerminalGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(f"SerialCom v{VERSION}")
        self.setFixedSize(600, 780)
        self.terminal_dialog = None
        self.open_terminals = []  # Track multiple open terminals
        self.tftp_process = None
        self._pending_profile_name = None
        self.config = ConfigManager()
        self.init_ui()
        self.apply_styles()
        self.load_settings()

    def init_ui(self):
        """Initialize the user interface with vertical tabs"""
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main horizontal layout (tabs on left, content on right)
        main_h_layout = QHBoxLayout()
        main_h_layout.setSpacing(0)
        main_h_layout.setContentsMargins(0, 0, 0, 0)

        # === LEFT SIDE: Vertical Tab Bar ===
        self.tab_widget = QWidget()
        self.tab_widget.setFixedWidth(50)
        self.tab_widget.setStyleSheet("""
            QWidget {
                background-color: #37474f;
                border-right: 1px solid #263238;
            }
        """)

        tab_layout = QVBoxLayout()
        tab_layout.setContentsMargins(5, 10, 5, 10)
        tab_layout.setSpacing(10)

        # Serial tab button
        self.serial_tab_btn = QPushButton()
        self.serial_tab_btn.setFixedSize(40, 40)
        # Load custom serial port icon
        serial_icon_path = self.get_tab_icon_path('serial-port-white.svg')
        if serial_icon_path:
            self.serial_tab_btn.setIcon(QIcon(serial_icon_path))
            self.serial_tab_btn.setIconSize(self.serial_tab_btn.size() * 0.95)
        else:
            self.serial_tab_btn.setIcon(self.style().standardIcon(
                self.style().StandardPixmap.SP_DriveHDIcon))
        self.serial_tab_btn.setToolTip("Serial Connection")
        self.serial_tab_btn.setCheckable(True)
        self.serial_tab_btn.clicked.connect(lambda: self.switch_tab(1))

        # SSH tab button
        self.ssh_tab_btn = QPushButton()
        self.ssh_tab_btn.setFixedSize(40, 40)
        # Load custom SSH icon
        ssh_icon_path = self.get_tab_icon_path('ssh_icon.svg')
        if ssh_icon_path:
            self.ssh_tab_btn.setIcon(QIcon(ssh_icon_path))
            self.ssh_tab_btn.setIconSize(self.ssh_tab_btn.size() * 0.95)
        else:
            self.ssh_tab_btn.setIcon(self.style().standardIcon(
                self.style().StandardPixmap.SP_ComputerIcon))
        self.ssh_tab_btn.setToolTip("SSH Connection")
        self.ssh_tab_btn.setCheckable(True)
        self.ssh_tab_btn.clicked.connect(lambda: self.switch_tab(2))

        # TFTP tab button
        self.tftp_tab_btn = QPushButton()
        self.tftp_tab_btn.setFixedSize(40, 40)
        tftp_icon_path = self.get_tab_icon_path('TFTP.svg')
        if tftp_icon_path:
            self.tftp_tab_btn.setIcon(QIcon(tftp_icon_path))
            self.tftp_tab_btn.setIconSize(self.tftp_tab_btn.size() * 0.95)
        else:
            self.tftp_tab_btn.setIcon(self.style().standardIcon(
                self.style().StandardPixmap.SP_DriveNetIcon))
        self.tftp_tab_btn.setToolTip("TFTP Server")
        self.tftp_tab_btn.setCheckable(True)
        self.tftp_tab_btn.setChecked(True)
        self.tftp_tab_btn.clicked.connect(lambda: self.switch_tab(0))

        # Style for tab buttons
        tab_btn_style = """
            QPushButton {
                background-color: transparent;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #546e7a;
            }
            QPushButton:checked {
                background-color: #4caf50;
                border: none;
            }
        """
        self.serial_tab_btn.setStyleSheet(tab_btn_style)
        self.ssh_tab_btn.setStyleSheet(tab_btn_style)
        self.tftp_tab_btn.setStyleSheet(tab_btn_style)

        tab_layout.addWidget(self.tftp_tab_btn)
        tab_layout.addWidget(self.serial_tab_btn)
        tab_layout.addWidget(self.ssh_tab_btn)
        tab_layout.addStretch()
        self.tab_widget.setLayout(tab_layout)

        # === RIGHT SIDE: Stacked Widget for Content ===
        self.content_stack = QStackedWidget()

        # Create TFTP server page (index 0)
        self.tftp_page = self.create_tftp_page()
        self.content_stack.addWidget(self.tftp_page)

        # Create Serial configuration page (index 1)
        self.serial_page = self.create_serial_page()
        self.content_stack.addWidget(self.serial_page)

        # Create SSH configuration page (index 2)
        self.ssh_page = self.create_ssh_page()
        self.content_stack.addWidget(self.ssh_page)

        # Add to main layout
        main_h_layout.addWidget(self.tab_widget)
        main_h_layout.addWidget(self.content_stack, 1)

        central_widget.setLayout(main_h_layout)

        # Update port list
        self.update_port_list()

    def switch_tab(self, index):
        """Switch between TFTP, Serial and SSH tabs"""
        self.content_stack.setCurrentIndex(index)
        self.tftp_tab_btn.setChecked(index == 0)
        self.serial_tab_btn.setChecked(index == 1)
        self.ssh_tab_btn.setChecked(index == 2)
        modes = {0: 'tftp', 1: 'serial', 2: 'ssh'}
        self.config.set('connection_mode', modes.get(index, 'tftp'))

    def create_serial_page(self):
        """Create the serial connection configuration page"""
        page = QWidget()
        main_layout = QVBoxLayout()
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(15, 15, 15, 15)

        # Standard width for all comboboxes
        combo_width = 200

        # Port configuration group
        port_group = QGroupBox("Port Configuration")
        port_layout = QFormLayout()
        port_layout.setVerticalSpacing(8)
        port_layout.setContentsMargins(10, 10, 10, 10)
        port_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        port_layout.setFormAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Port type
        self.port_type = QComboBox()
        self.port_type.addItems(['USB', 'Serial'])
        self.port_type.setCurrentIndex(0)
        self.port_type.setFixedWidth(combo_width)
        self.port_type.setToolTip("Select the type of serial port")
        self.port_type.currentIndexChanged.connect(self.update_port_list)
        port_layout.addRow("Type:", self.port_type)

        # Port
        self.port = QComboBox()
        self.port.setFixedWidth(combo_width)
        self.port.setToolTip("Select the serial port to connect")
        port_layout.addRow("Port:", self.port)

        port_group.setLayout(port_layout)

        # Add shadow effect to port group
        shadow1 = QGraphicsDropShadowEffect()
        shadow1.setBlurRadius(15)
        shadow1.setXOffset(0)
        shadow1.setYOffset(2)
        shadow1.setColor(QColor(0, 0, 0, 30))
        port_group.setGraphicsEffect(shadow1)

        main_layout.addWidget(port_group)

        # Communication parameters group
        comm_group = QGroupBox("Communication Parameters")
        comm_layout = QFormLayout()
        comm_layout.setVerticalSpacing(8)
        comm_layout.setContentsMargins(10, 10, 10, 10)
        comm_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        comm_layout.setFormAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Baud Rate - MAIN FIELD (highlighted)
        velocity_label = QLabel("Baud Rate:")
        velocity_font = QFont("Sans Serif", 10, QFont.Weight.Bold)
        velocity_label.setFont(velocity_font)
        velocity_label.setStyleSheet("color: #2e7d32;")

        self.baudrate = QComboBox()
        self.baudrate.addItems([
            '300', '1200', '2400', '4800', '9600', '19200',
            '38400', '57600', '115200', '230400', '460800', '921600'
        ])
        self.baudrate.setCurrentText('9600')
        self.baudrate.setFixedWidth(combo_width)
        self.baudrate.setToolTip("Communication speed in bits per second")
        self.baudrate.setStyleSheet("""
            QComboBox {
                border: 2px solid #4caf50;
                background-color: #f1f8e9;
            }
            QComboBox:hover {
                border: 2px solid #2e7d32;
                background-color: #e8f5e9;
            }
        """)
        comm_layout.addRow(velocity_label, self.baudrate)

        # Data bits
        self.databits = QComboBox()
        self.databits.addItems(['5', '6', '7', '8'])
        self.databits.setCurrentText('8')
        self.databits.setFixedWidth(combo_width)
        self.databits.setToolTip("Number of data bits per character (usually 8)")
        comm_layout.addRow("Data Bits:", self.databits)

        # Parity
        self.parity = QComboBox()
        self.parity.addItems(['None', 'Even', 'Odd'])
        self.parity.setCurrentText('None')
        self.parity.setFixedWidth(combo_width)
        self.parity.setToolTip("Error detection method (usually None)")
        comm_layout.addRow("Parity:", self.parity)

        # Stop bits
        self.stopbits = QComboBox()
        self.stopbits.addItems(['1', '2'])
        self.stopbits.setCurrentText('1')
        self.stopbits.setFixedWidth(combo_width)
        self.stopbits.setToolTip("Number of stop bits (usually 1)")
        comm_layout.addRow("Stop Bits:", self.stopbits)

        # Flow control
        self.flow = QComboBox()
        self.flow.addItems(['None', 'Hardware (RTS/CTS)', 'Software (XON/XOFF)'])
        self.flow.setCurrentText('None')
        self.flow.setFixedWidth(combo_width)
        self.flow.setToolTip("Flow control method (usually None)")
        comm_layout.addRow("Flow Control:", self.flow)

        comm_group.setLayout(comm_layout)

        # Add shadow effect to comm group
        shadow2 = QGraphicsDropShadowEffect()
        shadow2.setBlurRadius(15)
        shadow2.setXOffset(0)
        shadow2.setYOffset(2)
        shadow2.setColor(QColor(0, 0, 0, 30))
        comm_group.setGraphicsEffect(shadow2)

        main_layout.addWidget(comm_group)

        # === Quick Connect (Saved Profiles) ===
        profiles_group = QGroupBox("Quick Connect")
        profiles_layout = QVBoxLayout()
        profiles_layout.setContentsMargins(10, 2, 10, 8)
        profiles_layout.setSpacing(6)

        self.serial_profiles_table = QTableWidget()
        self.serial_profiles_table.setColumnCount(4)
        self.serial_profiles_table.setHorizontalHeaderLabels(["Name", "Port", "Baud Rate", "Config"])
        self.serial_profiles_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.serial_profiles_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.serial_profiles_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
        self.serial_profiles_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.Fixed)
        self.serial_profiles_table.setColumnWidth(2, 80)
        self.serial_profiles_table.setColumnWidth(3, 70)
        self.serial_profiles_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.serial_profiles_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.serial_profiles_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.serial_profiles_table.verticalHeader().setVisible(False)
        self.serial_profiles_table.doubleClicked.connect(self.load_serial_profile_from_table)
        self.serial_profiles_table.setStyleSheet("""
            QTableWidget {
                background-color: #e8e8e8;
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                color: #333333;
                font-size: 9pt;
                gridline-color: #d0d0d0;
            }
            QTableWidget::item {
                padding: 4px;
                background-color: #e8e8e8;
            }
            QTableWidget::item:selected {
                background-color: #2196F3;
                color: white;
            }
            QHeaderView::section {
                background-color: #d0d0d0;
                color: #333333;
                padding: 4px;
                border: none;
                font-weight: bold;
                font-size: 9pt;
            }
        """)
        profiles_layout.addWidget(self.serial_profiles_table)

        serial_btn_layout = QHBoxLayout()
        serial_btn_layout.setSpacing(8)

        self.save_serial_profile_btn = QPushButton("Save Current")
        self.save_serial_profile_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.save_serial_profile_btn.setStyleSheet("""
            QPushButton {
                background-color: #78909c;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #607d8b;
            }
        """)
        self.save_serial_profile_btn.clicked.connect(self.save_current_serial_profile)

        self.delete_serial_profile_btn = QPushButton("Delete Selected")
        self.delete_serial_profile_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.delete_serial_profile_btn.setStyleSheet("""
            QPushButton {
                background-color: #9e9e9e;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #757575;
            }
        """)
        self.delete_serial_profile_btn.clicked.connect(self.delete_serial_profile)

        serial_btn_layout.addStretch()
        serial_btn_layout.addWidget(self.save_serial_profile_btn)
        serial_btn_layout.addWidget(self.delete_serial_profile_btn)
        serial_btn_layout.addStretch()
        profiles_layout.addLayout(serial_btn_layout)

        profiles_group.setLayout(profiles_layout)

        shadow3 = QGraphicsDropShadowEffect()
        shadow3.setBlurRadius(15)
        shadow3.setXOffset(0)
        shadow3.setYOffset(2)
        shadow3.setColor(QColor(0, 0, 0, 30))
        profiles_group.setGraphicsEffect(shadow3)

        main_layout.addWidget(profiles_group, 1)

        # Debug mode checkbox
        self.debug_checkbox = QCheckBox("Debug Mode (simulate Cisco router)")
        self.debug_checkbox.setToolTip("Enable to test terminal without a real device")
        self.debug_checkbox.setStyleSheet("color: #606060; font-size: 9pt;")
        main_layout.addWidget(self.debug_checkbox)

        # Connect button
        self.connect_btn = QPushButton("CONNECT")
        self.connect_btn.setMinimumHeight(40)
        self.connect_btn.setFont(QFont("Sans Serif", 11, QFont.Weight.Bold))
        self.connect_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.connect_btn.setStyleSheet("""
            QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 8px;
                padding: 8px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #43a047;
            }
            QPushButton:pressed {
                background-color: #388e3c;
            }
        """)
        self.connect_btn.clicked.connect(self.connect)
        main_layout.addWidget(self.connect_btn)

        # Status with LED indicator
        status_layout = QHBoxLayout()
        status_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        status_layout.setSpacing(8)

        self.status_led = QLabel("●")
        self.status_led.setStyleSheet("color: #4caf50; font-size: 14px;")

        self.status_label = QLabel("Ready to connect")
        self.status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")

        status_layout.addWidget(self.status_led)
        status_layout.addWidget(self.status_label)

        status_widget = QWidget()
        status_widget.setLayout(status_layout)
        main_layout.addWidget(status_widget)

        page.setLayout(main_layout)

        # Load saved serial profiles
        self.refresh_serial_profiles()

        return page

    def create_tftp_page(self):
        """Create the TFTP server configuration page"""
        page = QWidget()
        main_layout = QVBoxLayout()
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(20, 20, 20, 20)

        combo_width = 200

        # TFTP Server group
        tftp_group = QGroupBox("TFTP Server")
        tftp_layout = QFormLayout()
        tftp_layout.setVerticalSpacing(12)
        tftp_layout.setContentsMargins(15, 15, 15, 15)
        tftp_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        tftp_layout.setFormAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Network interface selector
        self.tftp_interface = QComboBox()
        self.tftp_interface.setFixedWidth(combo_width)
        self.tftp_interface.setToolTip("Select network interface for TFTP server")
        self.tftp_interface.setStyleSheet("""
            QComboBox {
                font-size: 8pt;
            }
        """)
        self.update_network_interfaces()
        tftp_layout.addRow("Interface:", self.tftp_interface)

        # TFTP directory with browse button and start button
        tftp_dir_layout = QHBoxLayout()
        tftp_dir_layout.setContentsMargins(0, 0, 0, 0)
        tftp_dir_layout.setSpacing(2)

        self.tftp_directory = QLineEdit()
        self.tftp_directory.setFixedWidth(combo_width)
        default_tftp_dir = os.environ.get('HOME', str(Path.home()))
        self.tftp_directory.setText(default_tftp_dir)
        self.tftp_directory.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.tftp_directory.setToolTip("Directory containing firmware files")
        self.tftp_directory.setStyleSheet("""
            QLineEdit {
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                padding: 4px 10px;
                background-color: #f5f5f5;
                color: #333333;
                font-size: 10pt;
            }
        """)

        self.tftp_browse_btn = QPushButton()
        self.tftp_browse_btn.setFixedSize(28, 28)
        self.tftp_browse_btn.setIcon(self.style().standardIcon(self.style().StandardPixmap.SP_DirOpenIcon))
        self.tftp_browse_btn.setToolTip("Browse for directory")
        self.tftp_browse_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.tftp_browse_btn.setStyleSheet("""
            QPushButton {
                background-color: #e0e0e0;
                border: 1px solid #bdbdbd;
                border-radius: 6px;
            }
            QPushButton:hover {
                background-color: #d0d0d0;
                border: 1px solid #9e9e9e;
            }
            QPushButton:pressed {
                background-color: #bdbdbd;
            }
        """)
        self.tftp_browse_btn.clicked.connect(self.browse_tftp_directory)

        self.tftp_btn = QPushButton("Start TFTP")
        self.tftp_btn.setFixedHeight(28)
        self.tftp_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.tftp_btn.clicked.connect(self.toggle_tftp_server)
        self.tftp_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 4px 16px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)

        tftp_dir_layout.addWidget(self.tftp_directory)
        tftp_dir_layout.addWidget(self.tftp_browse_btn)
        tftp_dir_layout.addSpacing(8)
        tftp_dir_layout.addWidget(self.tftp_btn)
        tftp_dir_layout.addStretch()

        tftp_dir_widget = QWidget()
        tftp_dir_widget.setContentsMargins(0, 0, 0, 0)
        tftp_dir_widget.setLayout(tftp_dir_layout)
        tftp_layout.addRow("Directory:", tftp_dir_widget)

        tftp_group.setLayout(tftp_layout)

        # Add shadow effect to tftp group
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(15)
        shadow.setXOffset(0)
        shadow.setYOffset(2)
        shadow.setColor(QColor(0, 0, 0, 30))
        tftp_group.setGraphicsEffect(shadow)

        main_layout.addWidget(tftp_group)

        # Initialize TFTP server instance
        self.tftp_server = None

        # === Directory Contents ===
        files_group = QGroupBox("Directory Contents")
        files_layout = QVBoxLayout()
        files_layout.setContentsMargins(10, 2, 10, 8)
        files_layout.setSpacing(6)

        self.tftp_files_table = QTableWidget()
        self.tftp_files_table.setColumnCount(3)
        self.tftp_files_table.setHorizontalHeaderLabels(["Name", "Size", "Modified"])
        self.tftp_files_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.tftp_files_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Fixed)
        self.tftp_files_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
        self.tftp_files_table.setColumnWidth(1, 80)
        self.tftp_files_table.setColumnWidth(2, 130)
        self.tftp_files_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.tftp_files_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.tftp_files_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tftp_files_table.verticalHeader().setVisible(False)
        self.tftp_files_table.setStyleSheet("""
            QTableWidget {
                background-color: #e8e8e8;
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                color: #333333;
                font-size: 9pt;
                gridline-color: #d0d0d0;
            }
            QTableWidget::item {
                padding: 4px;
                background-color: #e8e8e8;
            }
            QTableWidget::item:selected {
                background-color: #2196F3;
                color: white;
            }
            QHeaderView::section {
                background-color: #d0d0d0;
                color: #333333;
                padding: 4px;
                border: none;
                font-weight: bold;
                font-size: 9pt;
            }
        """)
        files_layout.addWidget(self.tftp_files_table)

        # Refresh button
        refresh_btn_layout = QHBoxLayout()
        refresh_btn_layout.addStretch()
        self.tftp_refresh_btn = QPushButton("Refresh")
        self.tftp_refresh_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.tftp_refresh_btn.setStyleSheet("""
            QPushButton {
                background-color: #78909c;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #607d8b;
            }
        """)
        self.tftp_refresh_btn.clicked.connect(self.refresh_tftp_files)
        refresh_btn_layout.addWidget(self.tftp_refresh_btn)

        self.tftp_copy_btn = QPushButton("Copy Name")
        self.tftp_copy_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.tftp_copy_btn.setStyleSheet("""
            QPushButton {
                background-color: #78909c;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #607d8b;
            }
        """)
        self.tftp_copy_btn.clicked.connect(self.copy_tftp_filename)
        refresh_btn_layout.addWidget(self.tftp_copy_btn)

        refresh_btn_layout.addStretch()
        files_layout.addLayout(refresh_btn_layout)

        files_group.setLayout(files_layout)

        shadow2 = QGraphicsDropShadowEffect()
        shadow2.setBlurRadius(15)
        shadow2.setXOffset(0)
        shadow2.setYOffset(2)
        shadow2.setColor(QColor(0, 0, 0, 30))
        files_group.setGraphicsEffect(shadow2)

        main_layout.addWidget(files_group, 1)

        # Load initial file list
        self.refresh_tftp_files()

        page.setLayout(main_layout)
        return page

    def create_ssh_page(self):
        """Create the SSH connection configuration page"""
        page = QWidget()
        main_layout = QVBoxLayout()
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(15, 15, 15, 15)

        combo_width = 200

        # Style for QLineEdit fields (compact)
        line_edit_style = """
            QLineEdit {
                border: 1px solid #d0d0d0;
                border-radius: 4px;
                padding: 2px 8px;
                background-color: #f5f5f5;
                color: #333333;
                font-size: 10pt;
            }
        """

        # === Remote Connection Group ===
        ssh_group = QGroupBox("Remote Connection")
        ssh_layout = QFormLayout()
        ssh_layout.setVerticalSpacing(8)
        ssh_layout.setContentsMargins(10, 10, 10, 10)
        ssh_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)

        # Protocol selection (SSH/Telnet)
        radio_style = """
            QRadioButton { color: #333333; font-size: 10pt; }
            QRadioButton::indicator {
                width: 14px;
                height: 14px;
                border-radius: 8px;
                border: 2px solid #aaaaaa;
                background-color: #ffffff;
            }
            QRadioButton::indicator:checked {
                border: 2px solid #4caf50;
                background-color: #4caf50;
            }
        """
        self.protocol_ssh_radio = QRadioButton("SSH")
        self.protocol_ssh_radio.setChecked(True)
        self.protocol_ssh_radio.setStyleSheet(radio_style)
        self.protocol_telnet_radio = QRadioButton("Telnet")
        self.protocol_telnet_radio.setStyleSheet(radio_style)

        self.protocol_button_group = QButtonGroup()
        self.protocol_button_group.addButton(self.protocol_ssh_radio, 0)
        self.protocol_button_group.addButton(self.protocol_telnet_radio, 1)
        self.protocol_button_group.buttonClicked.connect(self.toggle_protocol)

        protocol_widget = QWidget()
        protocol_layout = QHBoxLayout()
        protocol_layout.setContentsMargins(0, 0, 0, 0)
        protocol_layout.addWidget(self.protocol_ssh_radio)
        protocol_layout.addWidget(self.protocol_telnet_radio)
        protocol_layout.addStretch()
        protocol_widget.setLayout(protocol_layout)
        ssh_layout.addRow("Protocol:", protocol_widget)

        # Host
        self.ssh_host = QLineEdit()
        self.ssh_host.setFixedWidth(combo_width)
        self.ssh_host.setPlaceholderText("192.168.1.1 or hostname")
        self.ssh_host.setToolTip("SSH/Telnet server hostname or IP address")
        self.ssh_host.setStyleSheet(line_edit_style)
        ssh_layout.addRow("Host:", self.ssh_host)

        # Port
        self.ssh_port = QLineEdit()
        self.ssh_port.setFixedWidth(80)
        self.ssh_port.setText("22")
        self.ssh_port.setToolTip("SSH/Telnet port (default: 22 for SSH, 23 for Telnet)")
        self.ssh_port.setStyleSheet(line_edit_style)
        ssh_layout.addRow("Port:", self.ssh_port)

        # Username
        self.ssh_username = QLineEdit()
        self.ssh_username.setFixedWidth(combo_width)
        self.ssh_username.setPlaceholderText("admin")
        self.ssh_username.setToolTip("Username for authentication")
        self.ssh_username.setStyleSheet(line_edit_style)
        ssh_layout.addRow("Username:", self.ssh_username)

        # Password (for both SSH and Telnet)
        self.ssh_password = QLineEdit()
        self.ssh_password.setEchoMode(QLineEdit.EchoMode.Password)
        self.ssh_password.setFixedWidth(combo_width)
        self.ssh_password.setPlaceholderText("Leave blank to be prompted")
        self.ssh_password.setToolTip("Password for authentication (optional)")
        self.ssh_password.setStyleSheet(line_edit_style)
        ssh_layout.addRow("Password:", self.ssh_password)

        # SSH Key checkbox (for SSH only)
        self.use_ssh_key = QCheckBox("Use SSH Key instead of password")
        self.use_ssh_key.setStyleSheet("""
            QCheckBox { color: #333333; font-size: 10pt; }
            QCheckBox::indicator {
                width: 14px;
                height: 14px;
                border-radius: 3px;
                border: 2px solid #aaaaaa;
                background-color: #ffffff;
            }
            QCheckBox::indicator:checked {
                border: 2px solid #4caf50;
                background-color: #4caf50;
            }
        """)
        self.use_ssh_key.toggled.connect(self.toggle_ssh_key)
        ssh_layout.addRow("", self.use_ssh_key)

        # SSH Key file field (hidden by default)
        self.ssh_key_widget = QWidget()
        key_layout = QHBoxLayout()
        key_layout.setContentsMargins(0, 0, 0, 0)
        key_layout.setSpacing(5)

        self.ssh_key_path = QLineEdit()
        self.ssh_key_path.setFixedWidth(combo_width - 30)
        self.ssh_key_path.setPlaceholderText("~/.ssh/id_rsa")
        self.ssh_key_path.setStyleSheet(line_edit_style)

        self.ssh_key_browse = QPushButton()
        self.ssh_key_browse.setFixedSize(24, 24)
        self.ssh_key_browse.setIcon(self.style().standardIcon(
            self.style().StandardPixmap.SP_FileIcon))
        self.ssh_key_browse.setToolTip("Browse for SSH key file")
        self.ssh_key_browse.setCursor(Qt.CursorShape.PointingHandCursor)
        self.ssh_key_browse.setStyleSheet("""
            QPushButton {
                background-color: #e0e0e0;
                border: 1px solid #bdbdbd;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #d0d0d0;
                border: 1px solid #9e9e9e;
            }
        """)
        self.ssh_key_browse.clicked.connect(self.browse_ssh_key)

        key_layout.addWidget(self.ssh_key_path)
        key_layout.addWidget(self.ssh_key_browse)
        self.ssh_key_widget.setLayout(key_layout)
        self.ssh_key_widget.setVisible(False)
        ssh_layout.addRow("Key File:", self.ssh_key_widget)

        ssh_group.setLayout(ssh_layout)

        # Add shadow effect
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(15)
        shadow.setXOffset(0)
        shadow.setYOffset(2)
        shadow.setColor(QColor(0, 0, 0, 30))
        ssh_group.setGraphicsEffect(shadow)

        main_layout.addWidget(ssh_group)

        # === Saved Profiles Group ===
        profiles_group = QGroupBox("Quick Connect")
        profiles_layout = QVBoxLayout()
        profiles_layout.setContentsMargins(10, 2, 10, 8)
        profiles_layout.setSpacing(6)

        # Profiles table (at the top)
        self.ssh_profiles_table = QTableWidget()
        self.ssh_profiles_table.setColumnCount(5)
        self.ssh_profiles_table.setHorizontalHeaderLabels(["Name", "Host", "Port", "Protocol", "Authentication"])
        self.ssh_profiles_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.ssh_profiles_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.ssh_profiles_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
        self.ssh_profiles_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.Fixed)
        self.ssh_profiles_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeMode.Stretch)
        self.ssh_profiles_table.setColumnWidth(2, 50)
        self.ssh_profiles_table.setColumnWidth(3, 70)
        self.ssh_profiles_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.ssh_profiles_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.ssh_profiles_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.ssh_profiles_table.verticalHeader().setVisible(False)
        self.ssh_profiles_table.doubleClicked.connect(self.load_ssh_profile_from_table)
        self.ssh_profiles_table.setStyleSheet("""
            QTableWidget {
                background-color: #e8e8e8;
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                color: #333333;
                font-size: 9pt;
                gridline-color: #d0d0d0;
            }
            QTableWidget::item {
                padding: 4px;
                background-color: #e8e8e8;
            }
            QTableWidget::item:selected {
                background-color: #2196F3;
                color: white;
            }
            QHeaderView::section {
                background-color: #d0d0d0;
                color: #333333;
                padding: 4px;
                border: none;
                font-weight: bold;
                font-size: 9pt;
            }
        """)
        profiles_layout.addWidget(self.ssh_profiles_table)

        # Buttons row (centered, below table)
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(8)

        self.save_profile_btn = QPushButton("Save Current")
        self.save_profile_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.save_profile_btn.setStyleSheet("""
            QPushButton {
                background-color: #78909c;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #607d8b;
            }
        """)
        self.save_profile_btn.clicked.connect(self.save_current_ssh_profile)

        self.delete_profile_btn = QPushButton("Delete Selected")
        self.delete_profile_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.delete_profile_btn.setStyleSheet("""
            QPushButton {
                background-color: #9e9e9e;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #757575;
            }
        """)
        self.delete_profile_btn.clicked.connect(self.delete_ssh_profile)

        btn_layout.addStretch()
        btn_layout.addWidget(self.save_profile_btn)
        btn_layout.addWidget(self.delete_profile_btn)
        btn_layout.addStretch()
        profiles_layout.addLayout(btn_layout)

        profiles_group.setLayout(profiles_layout)

        # Add shadow
        shadow3 = QGraphicsDropShadowEffect()
        shadow3.setBlurRadius(15)
        shadow3.setXOffset(0)
        shadow3.setYOffset(2)
        shadow3.setColor(QColor(0, 0, 0, 30))
        profiles_group.setGraphicsEffect(shadow3)

        main_layout.addWidget(profiles_group, 1)  # stretch factor 1 to expand

        # Connect SSH button
        self.ssh_connect_btn = QPushButton("CONNECT SSH")
        self.ssh_connect_btn.setMinimumHeight(45)
        self.ssh_connect_btn.setFont(QFont("Sans Serif", 11, QFont.Weight.Bold))
        self.ssh_connect_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.ssh_connect_btn.setStyleSheet("""
            QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 8px;
                padding: 12px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #43a047;
            }
            QPushButton:pressed {
                background-color: #388e3c;
            }
        """)
        self.ssh_connect_btn.clicked.connect(self.connect_ssh)
        main_layout.addWidget(self.ssh_connect_btn)

        # SSH Status
        ssh_status_layout = QHBoxLayout()
        ssh_status_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        ssh_status_layout.setSpacing(8)

        self.ssh_status_led = QLabel("●")
        self.ssh_status_led.setStyleSheet("color: #4caf50; font-size: 14px;")

        self.ssh_status_label = QLabel("Ready for SSH connection")
        self.ssh_status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")

        ssh_status_layout.addWidget(self.ssh_status_led)
        ssh_status_layout.addWidget(self.ssh_status_label)

        ssh_status_widget = QWidget()
        ssh_status_widget.setLayout(ssh_status_layout)
        main_layout.addWidget(ssh_status_widget)

        page.setLayout(main_layout)

        # Load saved SSH profiles
        self.refresh_ssh_profiles()

        return page

    def get_icon_path(self, icon_name):
        """Get the path to an icon from assets/icons for different installation types"""
        # Check for Flatpak
        flatpak_path = f'/app/share/io.github.benjamimgois.serialcom/icons/{icon_name}'
        if os.path.exists(flatpak_path):
            return flatpak_path
        # Check for AppImage
        if os.environ.get('APPDIR'):
            appdir = os.environ.get('APPDIR')
            appimage_path = os.path.join(appdir, f'usr/share/serialcom/icons/{icon_name}')
            if os.path.exists(appimage_path):
                return appimage_path
        # Local installation or development - assets/icons
        assets_path = os.path.join(os.path.dirname(__file__), f'assets/icons/{icon_name}')
        if os.path.exists(assets_path):
            return assets_path
        # Legacy: root directory
        root_path = os.path.join(os.path.dirname(__file__), icon_name)
        if os.path.exists(root_path):
            return root_path
        return None

    def get_arrow_icon_path(self):
        """Get the path to arrow_down.svg"""
        return self.get_icon_path('arrow_down.svg') or ''

    def get_tab_icon_path(self, icon_name):
        """Get the path to tab icons"""
        return self.get_icon_path(icon_name)

    def apply_styles(self):
        """Apply modern light theme to the application"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f0f0f0;
            }
            QGroupBox {
                border: 1px solid #e8e8e8;
                border-radius: 8px;
                margin-top: 15px;
                padding-top: 18px;
                background-color: #ffffff;
                color: #2c2c2c;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 15px;
                padding: 0 8px;
                color: #2c2c2c;
                font-size: 11pt;
                font-weight: bold;
                background-color: #ffffff;
            }
            QComboBox {
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                padding: 4px 28px 4px 10px;
                background-color: #fafafa;
                min-height: 24px;
                color: #2c2c2c;
                font-size: 10pt;
            }
            QComboBox::drop-down {
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 25px;
                border-left: 1px solid #d0d0d0;
                border-top-right-radius: 5px;
                border-bottom-right-radius: 5px;
                background-color: transparent;
            }
            QComboBox::down-arrow {
                image: url(""" + self.get_arrow_icon_path() + """);
                width: 12px;
                height: 12px;
            }
            QComboBox:hover {
                border: 1px solid #a0a0a0;
                background-color: #ffffff;
            }
            QComboBox:focus {
                border: 2px solid #4caf50;
            }
            QComboBox QAbstractItemView {
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                background-color: #ffffff;
                selection-background-color: #e8f5e9;
                selection-color: #2c2c2c;
                color: #2c2c2c;
                padding: 4px;
                outline: none;
            }
            QComboBox QAbstractItemView::item {
                padding: 6px;
                min-height: 24px;
            }
            QComboBox QAbstractItemView::item:hover {
                background-color: #f5f5f5;
            }
            QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 8px;
                padding: 12px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #43a047;
            }
            QPushButton:pressed {
                background-color: #388e3c;
            }
            QLabel {
                color: #2c2c2c;
            }
            QFormLayout QLabel {
                color: #4a4a4a;
            }
            QMessageBox {
                background-color: #ffffff;
            }
            QMessageBox QLabel {
                color: #2c2c2c;
                font-size: 10pt;
            }
            QMessageBox QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px 16px;
                min-width: 80px;
            }
            QMessageBox QPushButton:hover {
                background-color: #43a047;
            }
            QToolTip {
                background-color: #424242;
                color: #ffffff;
                border: none;
                border-radius: 4px;
                padding: 5px 8px;
                font-size: 9pt;
            }
        """)

    def load_settings(self):
        """Load saved settings and apply to ComboBoxes"""
        # Load and set port type
        port_type = self.config.get('port_type')
        index = self.port_type.findText(port_type)
        if index >= 0:
            self.port_type.setCurrentIndex(index)

        # Load and set baudrate
        baudrate = self.config.get('baudrate')
        index = self.baudrate.findText(baudrate)
        if index >= 0:
            self.baudrate.setCurrentIndex(index)

        # Load and set databits
        databits = self.config.get('databits')
        index = self.databits.findText(databits)
        if index >= 0:
            self.databits.setCurrentIndex(index)

        # Load and set parity
        parity = self.config.get('parity')
        index = self.parity.findText(parity)
        if index >= 0:
            self.parity.setCurrentIndex(index)

        # Load and set stopbits
        stopbits = self.config.get('stopbits')
        index = self.stopbits.findText(stopbits)
        if index >= 0:
            self.stopbits.setCurrentIndex(index)

        # Load and set flow
        flow = self.config.get('flow')
        index = self.flow.findText(flow)
        if index >= 0:
            self.flow.setCurrentIndex(index)

        # Connect signals to save settings when changed
        self.port_type.currentTextChanged.connect(lambda text: self.config.set('port_type', text))
        self.baudrate.currentTextChanged.connect(lambda text: self.config.set('baudrate', text))
        self.databits.currentTextChanged.connect(lambda text: self.config.set('databits', text))
        self.parity.currentTextChanged.connect(lambda text: self.config.set('parity', text))
        self.stopbits.currentTextChanged.connect(lambda text: self.config.set('stopbits', text))
        self.flow.currentTextChanged.connect(lambda text: self.config.set('flow', text))

    def update_port_list(self):
        """Update the list of available ports"""
        self.port.clear()

        port_type = self.port_type.currentText()

        # Use glob to search for ports based on type
        if port_type == 'Serial':
            pattern = '/dev/ttyS*'
        else:  # USB
            pattern = '/dev/ttyUSB*'

        ports = sorted(glob.glob(pattern))

        if ports:
            self.port.addItems(ports)
            self.status_label.setText(f"{len(ports)} port(s) found")
            self.status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #4caf50; font-size: 14px;")
        else:
            self.port.addItem("No ports found")
            self.status_label.setText("No serial ports available")
            self.status_label.setStyleSheet("color: #ff9800; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #ff9800; font-size: 14px;")

    def update_network_interfaces(self):
        """Update the list of network interfaces"""
        self.tftp_interface.clear()
        interfaces = get_network_interfaces()

        if interfaces:
            for iface, ip in interfaces:
                self.tftp_interface.addItem(f"{iface} ({ip})", ip)
        else:
            self.tftp_interface.addItem("No interfaces found", "")

    def browse_tftp_directory(self):
        """Open dialog to select TFTP directory"""
        directory = QFileDialog.getExistingDirectory(
            self,
            "Select TFTP Directory",
            self.tftp_directory.text()
        )
        if directory:
            self.tftp_directory.setText(directory)
            self.refresh_tftp_files()

    def refresh_tftp_files(self):
        """Refresh the TFTP directory file listing"""
        self.tftp_files_table.setRowCount(0)
        directory = self.tftp_directory.text()
        if not os.path.isdir(directory):
            return
        try:
            from datetime import datetime
            entries = sorted(os.listdir(directory))
            for name in entries:
                filepath = os.path.join(directory, name)
                if not os.path.isfile(filepath):
                    continue
                row = self.tftp_files_table.rowCount()
                self.tftp_files_table.insertRow(row)
                self.tftp_files_table.setItem(row, 0, QTableWidgetItem(name))
                # Format size
                size = os.path.getsize(filepath)
                if size < 1024:
                    size_str = f"{size} B"
                elif size < 1024 * 1024:
                    size_str = f"{size / 1024:.1f} KB"
                else:
                    size_str = f"{size / (1024 * 1024):.1f} MB"
                self.tftp_files_table.setItem(row, 1, QTableWidgetItem(size_str))
                # Format date
                mtime = os.path.getmtime(filepath)
                date_str = datetime.fromtimestamp(mtime).strftime("%Y-%m-%d %H:%M")
                self.tftp_files_table.setItem(row, 2, QTableWidgetItem(date_str))
        except OSError:
            pass

    def copy_tftp_filename(self):
        """Copy the selected TFTP file name to the clipboard"""
        selected = self.tftp_files_table.currentRow()
        if selected >= 0:
            item = self.tftp_files_table.item(selected, 0)
            if item:
                QApplication.clipboard().setText(item.text())
                original_text = self.tftp_copy_btn.text()
                self.tftp_copy_btn.setText("Copied!")
                self.tftp_copy_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #4caf50;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        font-weight: bold;
                        padding: 6px 12px;
                    }
                """)
                QTimer.singleShot(1500, lambda: self._reset_copy_btn(original_text))

    def _reset_copy_btn(self, text):
        """Restore the copy button to its default style"""
        self.tftp_copy_btn.setText(text)
        self.tftp_copy_btn.setStyleSheet("""
            QPushButton {
                background-color: #78909c;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #607d8b;
            }
        """)

    def toggle_tftp_server(self):
        """Start or stop the TFTP server"""
        if self.tftp_process is not None:
            # Stop server
            self.tftp_process.terminate()
            self.tftp_process.wait()
            self.tftp_process = None
            self.tftp_btn.setText("Start TFTP")
            self.tftp_btn.setStyleSheet("""
                QPushButton {
                    background-color: #2196F3;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-weight: bold;
                    padding: 4px 16px;
                }
                QPushButton:hover {
                    background-color: #1976D2;
                }
            """)
            self.tftp_interface.setEnabled(True)
            self.tftp_directory.setEnabled(True)
            self.tftp_browse_btn.setEnabled(True)
        else:
            # Get selected interface IP
            ip = self.tftp_interface.currentData()
            if not ip:
                QMessageBox.warning(self, "Warning", "No network interface selected")
                return

            directory = self.tftp_directory.text()
            if not os.path.isdir(directory):
                QMessageBox.warning(self, "Warning", "Invalid TFTP directory")
                return

            # Ask for sudo password with custom dialog (to ensure light theme)
            password_dialog = QDialog(self)
            password_dialog.setWindowTitle("Sudo Password Required")
            password_dialog.setModal(True)
            password_dialog.setFixedSize(400, 150)
            
            # Apply dark theme styling to dialog
            password_dialog.setStyleSheet("""
                QDialog { background-color: #1e1e2e; }
                QLabel { color: #cdd6f4; font-size: 10pt; }
                QLineEdit {
                    background-color: #313244; color: #cdd6f4;
                    border: 1px solid #585b70; border-radius: 6px;
                    padding: 8px; font-size: 10pt;
                }
                QLineEdit:focus { border: 2px solid #89b4fa; }
                QPushButton {
                    background-color: #89b4fa; color: #1e1e2e;
                    border: none; border-radius: 6px;
                    padding: 8px 16px; font-weight: bold; min-width: 80px;
                }
                QPushButton:hover { background-color: #74c7ec; }
                QPushButton#cancelButton { background-color: #585b70; color: #cdd6f4; }
                QPushButton#cancelButton:hover { background-color: #6c7086; }
            """)
            
            layout = QVBoxLayout()
            
            label = QLabel("TFTP port 69 requires root privileges.\nPlease enter your sudo password:")
            layout.addWidget(label)
            
            password_input = QLineEdit()
            password_input.setEchoMode(QLineEdit.EchoMode.Password)
            layout.addWidget(password_input)
            
            button_layout = QHBoxLayout()
            button_layout.addStretch()
            
            ok_button = QPushButton("OK")
            ok_button.clicked.connect(password_dialog.accept)
            button_layout.addWidget(ok_button)
            
            cancel_button = QPushButton("Cancel")
            cancel_button.setObjectName("cancelButton")
            cancel_button.clicked.connect(password_dialog.reject)
            button_layout.addWidget(cancel_button)
            
            layout.addLayout(button_layout)
            password_dialog.setLayout(layout)
            
            # Show dialog and get result
            if password_dialog.exec() != QDialog.DialogCode.Accepted:
                return
            
            password = password_input.text()
            if not password:
                return

            # Build command to run TFTP server with sudo
            script_path = os.path.abspath(__file__)
            cmd = ['sudo', '-S', sys.executable, script_path, '--tftp-server', ip, '69', directory]

            try:
                # Redirect TFTP server output to terminal for debugging
                print(f"[SerialCom] Starting TFTP server on {ip}:69")
                print(f"[SerialCom] Directory: {directory}")
                
                self.tftp_process = subprocess.Popen(
                    cmd,
                    stdin=subprocess.PIPE,
                    stdout=None,  # Inherit parent's stdout (terminal)
                    stderr=None,  # Inherit parent's stderr (terminal)
                    text=False
                )
                # Send password
                self.tftp_process.stdin.write((password + '\n').encode())
                self.tftp_process.stdin.flush()
                self.tftp_process.stdin.close()  # Close stdin after sending password
                password = None  # Clear from memory

                # Wait a moment to check if server started
                import time
                time.sleep(2.0)  # Increased timeout to allow server to start

                if self.tftp_process.poll() is not None:
                    # Process ended, probably failed
                    QMessageBox.critical(
                        self,
                        "Error",
                        f"Failed to start TFTP server.\n\nCheck terminal output for error details."
                    )
                    self.tftp_process = None
                    return

                print(f"[SerialCom] TFTP server started successfully")
                
                QMessageBox.information(
                    self,
                    "TFTP Server",
                    f"TFTP server started on {ip}:69\n\n"
                    f"Directory: {directory}\n\n"
                    f"Check terminal for debug messages."
                )

            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to start TFTP server.\n\n{str(e)}"
                )
                self.tftp_process = None
                return

            self.tftp_btn.setText("Stop TFTP")
            self.tftp_btn.setStyleSheet("""
                QPushButton {
                    background-color: #f44336;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-weight: bold;
                    padding: 4px 16px;
                }
                QPushButton:hover {
                    background-color: #d32f2f;
                }
            """)
            self.tftp_interface.setEnabled(False)
            self.tftp_directory.setEnabled(False)
            self.tftp_browse_btn.setEnabled(False)

    def build_picocom_command(self):
        """Build the picocom command with configured parameters"""
        port = self.port.currentText()

        if 'No ports found' in port or not port:
            return None

        baudrate = self.baudrate.currentText()
        databits = self.databits.currentText()

        # Parity
        parity_map = {'None': 'n', 'Even': 'e', 'Odd': 'o'}
        parity = parity_map[self.parity.currentText()]

        stopbits = self.stopbits.currentText()

        # Flow control
        flow_type = self.flow.currentText()
        if 'Hardware' in flow_type:
            flow = 'h'
        elif 'Software' in flow_type:
            flow = 's'
        else:
            flow = 'n'

        # Picocom command
        cmd = [
            'picocom',
            '-b', baudrate,
            '-d', databits,
            '-p', parity,
            '-f', flow,
            port
        ]

        # Add stop bits if 2
        if stopbits == '2':
            cmd.insert(-1, '-y')
            cmd.insert(-1, '2')

        return cmd

    # === SSH/Telnet Helper Methods ===

    def toggle_protocol(self, button):
        """Toggle between SSH and Telnet protocol"""
        if button == self.protocol_ssh_radio:
            # SSH selected
            self.ssh_port.setText("22")
            self.ssh_connect_btn.setText("CONNECT SSH")
        else:
            # Telnet selected
            self.ssh_port.setText("23")
            self.ssh_connect_btn.setText("CONNECT TELNET")

    def toggle_ssh_key(self, checked):
        """Toggle SSH key file widget visibility"""
        self.ssh_key_widget.setVisible(checked)

    def browse_ssh_key(self):
        """Open file dialog to select SSH private key"""
        key_file, _ = QFileDialog.getOpenFileName(
            self,
            "Select SSH Private Key",
            os.path.expanduser("~/.ssh"),
            "All Files (*)"
        )
        if key_file:
            self.ssh_key_path.setText(key_file)

    def refresh_ssh_profiles(self):
        """Refresh the SSH profiles table"""
        self.ssh_profiles_table.setRowCount(0)
        profiles = self.config.get_ssh_profiles()
        for profile in profiles:
            row = self.ssh_profiles_table.rowCount()
            self.ssh_profiles_table.insertRow(row)
            self.ssh_profiles_table.setItem(row, 0, QTableWidgetItem(profile.get('name', '')))
            self.ssh_profiles_table.setItem(row, 1, QTableWidgetItem(profile.get('host', '')))
            self.ssh_profiles_table.setItem(row, 2, QTableWidgetItem(profile.get('port', '22')))
            
            # Determine protocol based on port (22=SSH, 23=Telnet, or use saved protocol)
            port = profile.get('port', '22')
            protocol = profile.get('protocol', 'SSH' if port == '22' else 'Telnet' if port == '23' else 'SSH')
            self.ssh_profiles_table.setItem(row, 3, QTableWidgetItem(protocol))
            
            # Show authentication method
            auth_method = profile.get('auth_method', 'password')
            auth_display = 'SSH Key' if auth_method == 'key' else 'Password'
            self.ssh_profiles_table.setItem(row, 4, QTableWidgetItem(auth_display))
            
            # Store profile data in first column item
            self.ssh_profiles_table.item(row, 0).setData(Qt.ItemDataRole.UserRole, profile)



    def load_ssh_profile_from_table(self):
        """Load selected SSH profile from table and initiate connection"""
        row = self.ssh_profiles_table.currentRow()
        if row < 0:
            return
        item = self.ssh_profiles_table.item(row, 0)
        if item:
            profile = item.data(Qt.ItemDataRole.UserRole)
            if profile:
                self._pending_profile_name = profile.get('name', '')
                # Load profile data into form fields
                self.ssh_host.setText(profile.get('host', ''))
                self.ssh_port.setText(profile.get('port', '22'))
                self.ssh_username.setText(profile.get('username', ''))
                
                # Set authentication method
                if profile.get('auth_method') == 'key':
                    self.use_ssh_key.setChecked(True)
                    self.ssh_key_path.setText(profile.get('key_path', ''))
                else:
                    self.use_ssh_key.setChecked(False)
                
                # Set protocol (SSH or Telnet)
                # Use saved protocol, or detect from port if not saved
                port = profile.get('port', '22')
                protocol = profile.get('protocol')
                
                # Fallback: detect protocol from port if not explicitly saved
                if not protocol:
                    protocol = 'Telnet' if port == '23' else 'SSH'
                
                print(f"DEBUG: Loading profile with protocol: {protocol} (port: {port})")
                print(f"DEBUG: Full profile data: {profile}")
                
                if protocol == 'Telnet':
                    self.protocol_telnet_radio.setChecked(True)
                    print(f"DEBUG: Telnet radio checked: {self.protocol_telnet_radio.isChecked()}")
                    print(f"DEBUG: SSH radio checked: {self.protocol_ssh_radio.isChecked()}")
                    # Manually trigger toggle_protocol since buttonClicked signal isn't emitted
                    self.toggle_protocol(self.protocol_telnet_radio)
                else:
                    self.protocol_ssh_radio.setChecked(True)
                    print(f"DEBUG: SSH radio checked: {self.protocol_ssh_radio.isChecked()}")
                    print(f"DEBUG: Telnet radio checked: {self.protocol_telnet_radio.isChecked()}")
                    # Manually trigger toggle_protocol since buttonClicked signal isn't emitted
                    self.toggle_protocol(self.protocol_ssh_radio)
                
                # Force UI update before connecting
                QApplication.processEvents()
                
                # Use QTimer to delay connection slightly to ensure UI updates complete
                QTimer.singleShot(100, self.connect_ssh)






    def save_current_ssh_profile(self):
        """Save current SSH settings as a profile"""
        host = self.ssh_host.text().strip()
        if not host:
            QMessageBox.warning(self, "Warning", "Enter a host before saving")
            return

        name, ok = QInputDialog.getText(self, "Save Profile", "Profile name:")
        if ok and name:
            auth_method = 'key' if self.use_ssh_key.isChecked() else 'password'
            protocol = 'SSH' if self.protocol_ssh_radio.isChecked() else 'Telnet'
            self.config.save_ssh_profile(
                name, host, self.ssh_port.text(),
                self.ssh_username.text(), auth_method,
                self.ssh_key_path.text() if auth_method == 'key' else '',
                protocol
            )
            self.refresh_ssh_profiles()
            QMessageBox.information(self, "Saved", f"Profile '{name}' saved")

    def delete_ssh_profile(self):
        """Delete selected SSH profile from table"""
        row = self.ssh_profiles_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "Warning", "Select a profile to delete")
            return
        item = self.ssh_profiles_table.item(row, 0)
        if item:
            profile = item.data(Qt.ItemDataRole.UserRole)
            if profile:
                reply = QMessageBox.question(
                    self, "Delete Profile",
                    f"Delete profile '{profile['name']}'?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    self.config.delete_ssh_profile(profile['name'])
                    self.refresh_ssh_profiles()

    def refresh_serial_profiles(self):
        """Refresh the serial profiles table"""
        self.serial_profiles_table.setRowCount(0)
        profiles = self.config.get_serial_profiles()
        for profile in profiles:
            row = self.serial_profiles_table.rowCount()
            self.serial_profiles_table.insertRow(row)
            self.serial_profiles_table.setItem(row, 0, QTableWidgetItem(profile.get('name', '')))
            self.serial_profiles_table.setItem(row, 1, QTableWidgetItem(profile.get('port', '')))
            self.serial_profiles_table.setItem(row, 2, QTableWidgetItem(profile.get('baudrate', '9600')))
            # Config column: e.g. "8N1"
            databits = profile.get('databits', '8')
            parity = profile.get('parity', 'None')[0]  # N, E, O
            stopbits = profile.get('stopbits', '1')
            self.serial_profiles_table.setItem(row, 3, QTableWidgetItem(f"{databits}{parity}{stopbits}"))
            self.serial_profiles_table.item(row, 0).setData(Qt.ItemDataRole.UserRole, profile)

    def load_serial_profile_from_table(self):
        """Load selected serial profile from table and initiate connection"""
        row = self.serial_profiles_table.currentRow()
        if row < 0:
            return
        item = self.serial_profiles_table.item(row, 0)
        if item:
            profile = item.data(Qt.ItemDataRole.UserRole)
            if profile:
                # Load profile data into form fields
                idx = self.port.findText(profile.get('port', ''))
                if idx >= 0:
                    self.port.setCurrentIndex(idx)
                self.baudrate.setCurrentText(profile.get('baudrate', '9600'))
                self.databits.setCurrentText(profile.get('databits', '8'))
                self.parity.setCurrentText(profile.get('parity', 'None'))
                self.stopbits.setCurrentText(profile.get('stopbits', '1'))
                self.flow.setCurrentText(profile.get('flow', 'None'))
                QApplication.processEvents()
                QTimer.singleShot(100, self.connect)

    def save_current_serial_profile(self):
        """Save current serial settings as a profile"""
        port = self.port.currentText()
        if not port or 'No ports found' in port:
            QMessageBox.warning(self, "Warning", "Select a valid port before saving")
            return

        name, ok = QInputDialog.getText(self, "Save Profile", "Profile name:")
        if ok and name:
            self.config.save_serial_profile(
                name, port, self.baudrate.currentText(),
                self.databits.currentText(), self.parity.currentText(),
                self.stopbits.currentText(), self.flow.currentText()
            )
            self.refresh_serial_profiles()
            QMessageBox.information(self, "Saved", f"Profile '{name}' saved")

    def delete_serial_profile(self):
        """Delete selected serial profile from table"""
        row = self.serial_profiles_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "Warning", "Select a profile to delete")
            return
        item = self.serial_profiles_table.item(row, 0)
        if item:
            profile = item.data(Qt.ItemDataRole.UserRole)
            if profile:
                reply = QMessageBox.question(
                    self, "Delete Profile",
                    f"Delete profile '{profile['name']}'?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    self.config.delete_serial_profile(profile['name'])
                    self.refresh_serial_profiles()

    def connect_ssh(self):
        """Connect via SSH or Telnet"""
        host = self.ssh_host.text().strip()
        port = self.ssh_port.text().strip() or "22"
        username = self.ssh_username.text().strip()

        if not host:
            QMessageBox.warning(self, "Warning", "Enter host address")
            return

        # SSH connection requires paramiko
        if self.protocol_ssh_radio.isChecked() and not SSH_AVAILABLE:
            QMessageBox.critical(
                self, "Error",
                "paramiko library is not installed.\n\n"
                "Install with: pip install paramiko"
            )
            return

        # Username is required for SSH, optional for Telnet
        if self.protocol_ssh_radio.isChecked() and not username:
            QMessageBox.warning(self, "Warning", "Enter username for SSH connection")
            return

        # Get authentication credentials
        password = None
        key_path = None

        if self.use_ssh_key.isChecked():
            # SSH Key authentication
            key_path = self.ssh_key_path.text().strip()
            if not key_path:
                QMessageBox.warning(self, "Warning", "Select SSH key file")
                return
            key_path = os.path.expanduser(key_path)
        else:
            # Password authentication
            password = self.ssh_password.text()
            if not password:
                # Prompt for password if not entered
                password_dialog = QDialog(self)
                password_dialog.setWindowTitle("SSH Password")
                password_dialog.setModal(True)
                password_dialog.setFixedSize(420, 160)
                password_dialog.setStyleSheet("""
                    QDialog { background-color: #1e1e2e; }
                    QLabel { color: #cdd6f4; font-size: 10pt; }
                    QLineEdit {
                        background-color: #313244; color: #cdd6f4;
                        border: 1px solid #585b70; border-radius: 6px;
                        padding: 8px; font-size: 10pt;
                    }
                    QLineEdit:focus { border: 2px solid #89b4fa; }
                    QPushButton {
                        background-color: #89b4fa; color: #1e1e2e;
                        border: none; border-radius: 6px;
                        padding: 8px 16px; font-weight: bold; min-width: 80px;
                    }
                    QPushButton:hover { background-color: #74c7ec; }
                    QPushButton#cancelButton { background-color: #585b70; color: #cdd6f4; }
                    QPushButton#cancelButton:hover { background-color: #6c7086; }
                """)
                dlg_layout = QVBoxLayout()
                dlg_layout.addWidget(QLabel(f"Password for {username}@{host}:"))
                password_input = QLineEdit()
                password_input.setEchoMode(QLineEdit.EchoMode.Password)
                dlg_layout.addWidget(password_input)
                btn_layout = QHBoxLayout()
                ok_button = QPushButton("OK")
                ok_button.clicked.connect(password_dialog.accept)
                cancel_button = QPushButton("Cancel")
                cancel_button.setObjectName("cancelButton")
                cancel_button.clicked.connect(password_dialog.reject)
                btn_layout.addStretch()
                btn_layout.addWidget(ok_button)
                btn_layout.addWidget(cancel_button)
                dlg_layout.addLayout(btn_layout)
                password_dialog.setLayout(dlg_layout)
                if password_dialog.exec() != QDialog.DialogCode.Accepted:
                    return
                password = password_input.text()

        # Update status
        self.ssh_status_label.setText("Connecting...")
        self.ssh_status_label.setStyleSheet("color: #ff9800; font-size: 10pt;")
        self.ssh_status_led.setStyleSheet("color: #ff9800; font-size: 14px;")
        QApplication.processEvents()

        # Determine connection type
        connection_type = 'telnet' if self.protocol_telnet_radio.isChecked() else 'ssh'
        
        # Create and start connection worker thread
        self.connection_worker = ConnectionWorker(
            connection_type,
            host, port, username, password, key_path
        )
        
        # Connect signals
        self.connection_worker.connection_ready.connect(self.on_connection_ready)
        self.connection_worker.connection_failed.connect(self.on_connection_failed)
        
        # Start connection in background thread
        self.connection_worker.start()
    
    def on_connection_ready(self, conn_type, client, channel, host_info):
        """Handle successful connection from worker thread - create terminal in UI thread"""
        # Create terminal dialog in UI thread
        terminal_dialog = TerminalDialog(self, self.config)
        
        # Inject the established connection
        if conn_type == 'telnet':
            terminal_dialog.telnet_client = client
            terminal_dialog.telnet_running = True
            terminal_dialog.connection_type = 'telnet'
            title = f"SerialCom Terminal - Telnet: {host_info[0]}"
            if self._pending_profile_name:
                title = f"[{self._pending_profile_name}] {title}"
            terminal_dialog.setWindowTitle(title)
            
            # Start read thread
            terminal_dialog.telnet_read_thread = threading.Thread(
                target=terminal_dialog._telnet_read_loop, daemon=True
            )
            terminal_dialog.telnet_read_thread.start()
        else:  # SSH
            terminal_dialog.ssh_client = client
            terminal_dialog.ssh_channel = channel
            terminal_dialog.ssh_running = True
            terminal_dialog.connection_type = 'ssh'
            title = f"SerialCom Terminal - SSH: {host_info[2]}@{host_info[0]}"
            if self._pending_profile_name:
                title = f"[{self._pending_profile_name}] {title}"
            terminal_dialog.setWindowTitle(title)
            
            # Start read thread
            terminal_dialog.ssh_read_thread = threading.Thread(
                target=terminal_dialog._ssh_read_loop, daemon=True
            )
            terminal_dialog.ssh_read_thread.start()
        
        # Show profile name banner if connecting from Quick Connect
        if self._pending_profile_name:
            terminal_dialog.set_profile_name(self._pending_profile_name)
            self._pending_profile_name = None

        # Add to open terminals and show
        self.open_terminals.append(terminal_dialog)
        self.ssh_status_label.setText("Connected - Terminal opened")
        self.ssh_status_label.setStyleSheet("color: #4caf50; font-size: 10pt;")
        self.ssh_status_led.setStyleSheet("color: #4caf50; font-size: 14px;")
        terminal_dialog.show()
        # Resize PTY to match actual widget size after dialog is shown
        QTimer.singleShot(100, terminal_dialog.terminal._recalculate_size)
    
    def on_connection_failed(self, error_message):
        """Handle connection failure from worker thread"""
        self.ssh_status_label.setText("Connection failed")
        self.ssh_status_label.setStyleSheet("color: #f44336; font-size: 10pt;")
        self.ssh_status_led.setStyleSheet("color: #f44336; font-size: 14px;")
        if error_message:
            QMessageBox.critical(self, "Connection Error", error_message)

    def connect(self):
        """Connect to the serial port using embedded terminal"""
        # Check if debug mode is enabled
        if self.debug_checkbox.isChecked():
            self.status_label.setText("Opening debug terminal...")
            self.status_label.setStyleSheet("color: #fab387; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #fab387; font-size: 14px;")
            QApplication.processEvents()

            # Create and show terminal dialog in debug mode
            terminal_dialog = TerminalDialog(self, self.config)
            terminal_dialog.start_debug_mode()
            self.open_terminals.append(terminal_dialog)
            self.status_label.setText("Debug Mode - Terminal opened")
            self.status_label.setStyleSheet("color: #a6e3a1; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #a6e3a1; font-size: 14px;")
            terminal_dialog.show()

            # Status remains in debug mode (don't reset immediately)
            # Will reset when terminal is closed
            return

        # Check if picocom is installed
        try:
            subprocess.run(['which', 'picocom'], check=True, capture_output=True)
        except subprocess.CalledProcessError:
            QMessageBox.critical(
                self,
                "Error",
                "picocom is not installed.\n\n"
                "Install with:\nsudo pacman -S picocom"
            )
            return

        # Build command
        cmd = self.build_picocom_command()

        if not cmd:
            QMessageBox.warning(
                self,
                "Warning",
                "Select a valid serial port"
            )
            return

        self.status_label.setText("Opening terminal...")
        self.status_label.setStyleSheet("color: #fab387; font-size: 10pt;")
        self.status_led.setStyleSheet("color: #fab387; font-size: 14px;")
        QApplication.processEvents()

        # Create and show terminal dialog
        terminal_dialog = TerminalDialog(self, self.config)

        # Start picocom
        if terminal_dialog.start_picocom(cmd):
            self.open_terminals.append(terminal_dialog)
            self.status_label.setText("Connected - Terminal opened")
            self.status_label.setStyleSheet("color: #a6e3a1; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #a6e3a1; font-size: 14px;")
            terminal_dialog.show()

            # Status remains connected (don't reset immediately)
            # Will reset when terminal is closed
        else:
            self.status_label.setText("Connection error")
            self.status_label.setStyleSheet("color: #f38ba8; font-size: 10pt;")
            self.status_led.setStyleSheet("color: #f38ba8; font-size: 14px;")


def main():
    app = QApplication(sys.argv)

    # Set default font
    font = QFont("Sans Serif", 9)
    app.setFont(font)

    window = SerialTerminalGUI()
    window.show()

    sys.exit(app.exec())


if __name__ == '__main__':
    main()
